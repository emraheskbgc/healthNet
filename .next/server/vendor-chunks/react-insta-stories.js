/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-insta-stories";
exports.ids = ["vendor-chunks/react-insta-stories"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-insta-stories/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/react-insta-stories/dist/index.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n\telse {}\n})(this, (__WEBPACK_EXTERNAL_MODULE__639__) => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 931:\n/***/ ((__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_624__) => {\n\n__nested_webpack_require_624__.r(__nested_webpack_exports__);\n/* harmony export */ __nested_webpack_require_624__.d(__nested_webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_624__(639);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_624__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _excluded = [\"styles\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (_ref) {\n  var _ref$styles = _ref.styles,\n    styles = _ref$styles === void 0 ? {} : _ref$styles,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"svg\", _extends({\n    width: \"44\",\n    height: \"44\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    stroke: \"#fff\"\n  }, props), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"g\", {\n    fill: \"none\",\n    fillRule: \"evenodd\",\n    strokeWidth: \"2\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"circle\", {\n    cx: \"22\",\n    cy: \"22\",\n    r: \"1\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"animate\", {\n    attributeName: \"r\",\n    begin: \"0s\",\n    dur: \"1.8s\",\n    values: \"1; 20\",\n    calcMode: \"spline\",\n    keyTimes: \"0; 1\",\n    keySplines: \"0.165, 0.84, 0.44, 1\",\n    repeatCount: \"indefinite\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"animate\", {\n    attributeName: \"stroke-opacity\",\n    begin: \"0s\",\n    dur: \"1.8s\",\n    values: \"1; 0\",\n    calcMode: \"spline\",\n    keyTimes: \"0; 1\",\n    keySplines: \"0.3, 0.61, 0.355, 1\",\n    repeatCount: \"indefinite\"\n  })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"circle\", {\n    cx: \"22\",\n    cy: \"22\",\n    r: \"1\"\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"animate\", {\n    attributeName: \"r\",\n    begin: \"-0.9s\",\n    dur: \"1.8s\",\n    values: \"1; 20\",\n    calcMode: \"spline\",\n    keyTimes: \"0; 1\",\n    keySplines: \"0.165, 0.84, 0.44, 1\",\n    repeatCount: \"indefinite\"\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"animate\", {\n    attributeName: \"stroke-opacity\",\n    begin: \"-0.9s\",\n    dur: \"1.8s\",\n    values: \"1; 0\",\n    calcMode: \"spline\",\n    keyTimes: \"0; 1\",\n    keySplines: \"0.3, 0.61, 0.355, 1\",\n    repeatCount: \"indefinite\"\n  }))));\n});\n\n/***/ }),\n\n/***/ 120:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_4346__) {\n\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_4346__(639));\nvar Global_1 = __importDefault(__nested_webpack_require_4346__(267));\nvar Stories_1 = __importDefault(__nested_webpack_require_4346__(486));\nvar Progress_1 = __importDefault(__nested_webpack_require_4346__(552));\nvar Story_1 = __importDefault(__nested_webpack_require_4346__(832));\nvar ProgressArray_1 = __importDefault(__nested_webpack_require_4346__(913));\nvar use_is_mounted_1 = __importDefault(__nested_webpack_require_4346__(342));\nvar usePreLoader_1 = __nested_webpack_require_4346__(402);\nfunction default_1() {\n  var _ref = (0, react_1.useState)(0),\n    _ref2 = _slicedToArray(_ref, 2),\n    currentId = _ref2[0],\n    setCurrentId = _ref2[1];\n  var _ref3 = (0, react_1.useState)(true),\n    _ref4 = _slicedToArray(_ref3, 2),\n    pause = _ref4[0],\n    setPause = _ref4[1];\n  var _ref5 = (0, react_1.useState)(true),\n    _ref6 = _slicedToArray(_ref5, 2),\n    bufferAction = _ref6[0],\n    setBufferAction = _ref6[1];\n  var _ref7 = (0, react_1.useState)(0),\n    _ref8 = _slicedToArray(_ref7, 2),\n    videoDuration = _ref8[0],\n    setVideoDuration = _ref8[1];\n  var isMounted = (0, use_is_mounted_1[\"default\"])();\n  var mousedownId = (0, react_1.useRef)();\n  var _ref9 = (0, react_1.useContext)(Global_1[\"default\"]),\n    width = _ref9.width,\n    height = _ref9.height,\n    loop = _ref9.loop,\n    currentIndex = _ref9.currentIndex,\n    isPaused = _ref9.isPaused,\n    keyboardNavigation = _ref9.keyboardNavigation,\n    preventDefault = _ref9.preventDefault,\n    _ref9$storyContainerS = _ref9.storyContainerStyles,\n    storyContainerStyles = _ref9$storyContainerS === void 0 ? {} : _ref9$storyContainerS,\n    onAllStoriesEnd = _ref9.onAllStoriesEnd,\n    onPrevious = _ref9.onPrevious,\n    onNext = _ref9.onNext,\n    preloadCount = _ref9.preloadCount;\n  var _ref10 = (0, react_1.useContext)(Stories_1[\"default\"]),\n    stories = _ref10.stories;\n  (0, usePreLoader_1.usePreLoader)(stories, currentId, preloadCount);\n  (0, react_1.useEffect)(function () {\n    if (typeof currentIndex === \"number\") {\n      if (currentIndex >= 0 && currentIndex < stories.length) {\n        setCurrentIdWrapper(function () {\n          return currentIndex;\n        });\n      } else {\n        console.error(\"Index out of bounds. Current index was set to value more than the length of stories array.\", currentIndex);\n      }\n    }\n  }, [currentIndex]);\n  (0, react_1.useEffect)(function () {\n    if (typeof isPaused === \"boolean\") {\n      setPause(isPaused);\n    }\n  }, [isPaused]);\n  (0, react_1.useEffect)(function () {\n    var isClient = typeof window !== \"undefined\" && window.document;\n    if (isClient && typeof keyboardNavigation === \"boolean\" && keyboardNavigation) {\n      document.addEventListener(\"keydown\", handleKeyDown);\n      return function () {\n        document.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }\n  }, [keyboardNavigation]);\n  var handleKeyDown = function handleKeyDown(e) {\n    if (e.key === \"ArrowLeft\") {\n      previous();\n    } else if (e.key === \"ArrowRight\") {\n      next({\n        isSkippedByUser: true\n      });\n    }\n  };\n  var toggleState = function toggleState(action, bufferAction) {\n    setPause(action === \"pause\");\n    setBufferAction(!!bufferAction);\n  };\n  var setCurrentIdWrapper = function setCurrentIdWrapper(callback) {\n    setCurrentId(callback);\n    toggleState(\"pause\", true);\n  };\n  var previous = function previous() {\n    if (onPrevious != undefined) {\n      onPrevious();\n    }\n    setCurrentIdWrapper(function (prev) {\n      return prev > 0 ? prev - 1 : prev;\n    });\n  };\n  var next = function next(options) {\n    if (onNext != undefined && (options === null || options === void 0 ? void 0 : options.isSkippedByUser)) {\n      onNext();\n    }\n    // Check if component is mounted - for issue #130 (https://github.com/mohitk05/react-insta-stories/issues/130)\n    if (isMounted()) {\n      if (loop) {\n        updateNextStoryIdForLoop();\n      } else {\n        updateNextStoryId();\n      }\n    }\n  };\n  var updateNextStoryIdForLoop = function updateNextStoryIdForLoop() {\n    setCurrentIdWrapper(function (prev) {\n      if (prev >= stories.length - 1) {\n        onAllStoriesEnd && onAllStoriesEnd(currentId, stories);\n      }\n      return (prev + 1) % stories.length;\n    });\n  };\n  var updateNextStoryId = function updateNextStoryId() {\n    setCurrentIdWrapper(function (prev) {\n      if (prev < stories.length - 1) return prev + 1;\n      onAllStoriesEnd && onAllStoriesEnd(currentId, stories);\n      return prev;\n    });\n  };\n  var debouncePause = function debouncePause(e) {\n    e.preventDefault();\n    mousedownId.current = setTimeout(function () {\n      toggleState(\"pause\");\n    }, 200);\n  };\n  var mouseUp = function mouseUp(type) {\n    return function (e) {\n      e.preventDefault();\n      mousedownId.current && clearTimeout(mousedownId.current);\n      if (pause) {\n        toggleState(\"play\");\n      } else {\n        type === \"next\" ? next({\n          isSkippedByUser: true\n        }) : previous();\n      }\n    };\n  };\n  var getVideoDuration = function getVideoDuration(duration) {\n    setVideoDuration(duration * 1000);\n  };\n  return react_1[\"default\"].createElement(\"div\", {\n    style: Object.assign(Object.assign(Object.assign({}, styles.container), storyContainerStyles), {\n      width: width,\n      height: height\n    })\n  }, react_1[\"default\"].createElement(Progress_1[\"default\"].Provider, {\n    value: {\n      bufferAction: bufferAction,\n      videoDuration: videoDuration,\n      currentId: currentId,\n      pause: pause,\n      next: next\n    }\n  }, react_1[\"default\"].createElement(ProgressArray_1[\"default\"], null)), react_1[\"default\"].createElement(Story_1[\"default\"], {\n    action: toggleState,\n    bufferAction: bufferAction,\n    playState: pause,\n    story: stories[currentId],\n    getVideoDuration: getVideoDuration\n  }), !preventDefault && react_1[\"default\"].createElement(\"div\", {\n    style: styles.overlay\n  }, react_1[\"default\"].createElement(\"div\", {\n    style: {\n      width: \"50%\",\n      zIndex: 999\n    },\n    onTouchStart: debouncePause,\n    onTouchEnd: mouseUp(\"previous\"),\n    onMouseDown: debouncePause,\n    onMouseUp: mouseUp(\"previous\")\n  }), react_1[\"default\"].createElement(\"div\", {\n    style: {\n      width: \"50%\",\n      zIndex: 999\n    },\n    onTouchStart: debouncePause,\n    onTouchEnd: mouseUp(\"next\"),\n    onMouseDown: debouncePause,\n    onMouseUp: mouseUp(\"next\")\n  })));\n}\nexports[\"default\"] = default_1;\nvar styles = {\n  container: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    background: \"#111\",\n    position: \"relative\",\n    WebkitUserSelect: 'none'\n  },\n  overlay: {\n    position: \"absolute\",\n    height: \"inherit\",\n    width: \"inherit\",\n    display: \"flex\"\n  }\n};\n\n/***/ }),\n\n/***/ 463:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_13938__) {\n\n\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importDefault(__nested_webpack_require_13938__(639));\nvar Header = function Header(_ref) {\n  var profileImage = _ref.profileImage,\n    heading = _ref.heading,\n    subheading = _ref.subheading;\n  return react_1[\"default\"].createElement(\"div\", {\n    style: styles.main\n  }, profileImage && react_1[\"default\"].createElement(\"img\", {\n    style: styles.img,\n    src: profileImage\n  }), react_1[\"default\"].createElement(\"span\", {\n    style: styles.text\n  }, react_1[\"default\"].createElement(\"p\", {\n    style: styles.heading\n  }, heading), react_1[\"default\"].createElement(\"p\", {\n    style: styles.subheading\n  }, subheading)));\n};\nvar styles = {\n  main: {\n    display: \"flex\",\n    alignItems: \"center\"\n  },\n  img: {\n    width: 40,\n    height: 40,\n    borderRadius: 40,\n    marginRight: 10,\n    filter: \"drop-shadow(0 0px 2px rgba(0, 0, 0, 0.5))\",\n    border: \"2px solid rgba(255, 255, 255, 0.8)\"\n  },\n  text: {\n    display: \"flex\",\n    flexDirection: \"column\",\n    filter: \"drop-shadow(0 0px 3px rgba(0, 0, 0, 0.9))\"\n  },\n  heading: {\n    fontSize: \"1rem\",\n    color: \"rgba(255, 255, 255, 0.9)\",\n    margin: 0,\n    marginBottom: 2\n  },\n  subheading: {\n    fontSize: \"0.6rem\",\n    color: \"rgba(255, 255, 255, 0.8)\",\n    margin: 0\n  }\n};\nexports[\"default\"] = Header;\n\n/***/ }),\n\n/***/ 911:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_15505__) {\n\n\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_15505__(639));\nvar ProgressWrapper_1 = __importDefault(__nested_webpack_require_15505__(424));\nvar Global_1 = __importDefault(__nested_webpack_require_15505__(267));\nvar Progress_1 = __importDefault(__nested_webpack_require_15505__(552));\nexports[\"default\"] = function (props) {\n  var _ref = (0, react_1.useContext)(Global_1[\"default\"]),\n    progressStyles = _ref.progressStyles;\n  var _ref2 = (0, react_1.useContext)(Progress_1[\"default\"]),\n    bufferAction = _ref2.bufferAction,\n    pause = _ref2.pause;\n  var getProgressStyle = function getProgressStyle(_ref3) {\n    var active = _ref3.active;\n    switch (active) {\n      case 2:\n        return {\n          width: '100%'\n        };\n      case 1:\n        return {\n          transform: \"scaleX(\".concat(props.count / 100, \")\")\n        };\n      case 0:\n        return {\n          width: 0\n        };\n      default:\n        return {\n          width: 0\n        };\n    }\n  };\n  var width = props.width,\n    active = props.active;\n  return react_1[\"default\"].createElement(ProgressWrapper_1[\"default\"], {\n    width: width,\n    pause: pause,\n    bufferAction: bufferAction\n  }, react_1[\"default\"].createElement(\"div\", {\n    style: Object.assign(Object.assign(Object.assign({}, styles.inner), progressStyles), getProgressStyle({\n      active: active\n    }))\n  }));\n};\nvar styles = {\n  inner: {\n    background: '#fff',\n    height: '100%',\n    maxWidth: '100%',\n    borderRadius: 2,\n    transformOrigin: 'center left',\n    WebkitBackfaceVisibility: 'hidden',\n    MozBackfaceVisibility: 'hidden',\n    msBackfaceVisibility: 'hidden',\n    backfaceVisibility: 'hidden',\n    WebkitPerspective: 1000,\n    MozPerspective: 1000,\n    msPerspective: 1000,\n    perspective: 1000\n  }\n};\n\n/***/ }),\n\n/***/ 913:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_18560__) {\n\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_18560__(639));\nvar Progress_1 = __importDefault(__nested_webpack_require_18560__(911));\nvar Progress_2 = __importDefault(__nested_webpack_require_18560__(552));\nvar Global_1 = __importDefault(__nested_webpack_require_18560__(267));\nvar Stories_1 = __importDefault(__nested_webpack_require_18560__(486));\nvar time_1 = __nested_webpack_require_18560__(335);\nexports[\"default\"] = function () {\n  var _ref = (0, react_1.useState)(0),\n    _ref2 = _slicedToArray(_ref, 2),\n    count = _ref2[0],\n    setCount = _ref2[1];\n  var lastTime = (0, react_1.useRef)();\n  var _ref3 = (0, react_1.useContext)(Progress_2[\"default\"]),\n    currentId = _ref3.currentId,\n    next = _ref3.next,\n    videoDuration = _ref3.videoDuration,\n    pause = _ref3.pause,\n    bufferAction = _ref3.bufferAction;\n  var _ref4 = (0, react_1.useContext)(Global_1[\"default\"]),\n    defaultInterval = _ref4.defaultInterval,\n    onStoryEnd = _ref4.onStoryEnd,\n    onStoryStart = _ref4.onStoryStart,\n    progressContainerStyles = _ref4.progressContainerStyles;\n  var _ref5 = (0, react_1.useContext)(Stories_1[\"default\"]),\n    stories = _ref5.stories;\n  (0, react_1.useEffect)(function () {\n    setCount(0);\n  }, [currentId, stories]);\n  (0, react_1.useEffect)(function () {\n    if (!pause) {\n      animationFrameId.current = requestAnimationFrame(incrementCount);\n      lastTime.current = (0, time_1.timestamp)();\n    }\n    return function () {\n      cancelAnimationFrame(animationFrameId.current);\n    };\n  }, [currentId, pause]);\n  var animationFrameId = (0, react_1.useRef)();\n  var countCopy = count;\n  var incrementCount = function incrementCount() {\n    if (countCopy === 0) storyStartCallback();\n    if (lastTime.current == undefined) lastTime.current = (0, time_1.timestamp)();\n    var t = (0, time_1.timestamp)();\n    var dt = t - lastTime.current;\n    lastTime.current = t;\n    setCount(function (count) {\n      var interval = getCurrentInterval();\n      countCopy = count + dt * 100 / interval;\n      return countCopy;\n    });\n    if (countCopy < 100) {\n      animationFrameId.current = requestAnimationFrame(incrementCount);\n    } else {\n      storyEndCallback();\n      cancelAnimationFrame(animationFrameId.current);\n      next();\n    }\n  };\n  var storyStartCallback = function storyStartCallback() {\n    onStoryStart && onStoryStart(currentId, stories[currentId]);\n  };\n  var storyEndCallback = function storyEndCallback() {\n    onStoryEnd && onStoryEnd(currentId, stories[currentId]);\n  };\n  var getCurrentInterval = function getCurrentInterval() {\n    if (stories[currentId].type === \"video\") return videoDuration;\n    if (typeof stories[currentId].duration === \"number\") return stories[currentId].duration;\n    return defaultInterval;\n  };\n  var opacityStyles = {\n    opacity: pause && !bufferAction ? 0 : 1\n  };\n  return react_1[\"default\"].createElement(\"div\", {\n    style: Object.assign(Object.assign(Object.assign({}, styles.progressArr), progressContainerStyles), opacityStyles)\n  }, stories.map(function (_, i) {\n    return react_1[\"default\"].createElement(Progress_1[\"default\"], {\n      key: i,\n      count: count,\n      width: 1 / stories.length,\n      active: i === currentId ? 1 : i < currentId ? 2 : 0\n    });\n  }));\n};\nvar styles = {\n  progressArr: {\n    display: \"flex\",\n    justifyContent: \"center\",\n    maxWidth: \"100%\",\n    flexWrap: \"nowrap\",\n    position: \"absolute\",\n    width: \"98%\",\n    padding: 5,\n    paddingTop: 7,\n    alignSelf: \"center\",\n    zIndex: 1001,\n    filter: \"drop-shadow(0 1px 8px #222)\",\n    transition: \"opacity 400ms ease-in-out\"\n  }\n};\n\n/***/ }),\n\n/***/ 424:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_25035__) {\n\n\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_25035__(639));\nvar Global_1 = __importDefault(__nested_webpack_require_25035__(267));\nvar ProgressWrapper = function ProgressWrapper(props) {\n  var _ref = (0, react_1.useContext)(Global_1[\"default\"]),\n    progressWrapperStyles = _ref.progressWrapperStyles;\n  return react_1[\"default\"].createElement(\"div\", {\n    style: Object.assign(Object.assign(Object.assign({}, styles.progress), progressWrapperStyles), getProgressWrapperStyle(props))\n  }, props.children);\n};\nvar getProgressWrapperStyle = function getProgressWrapperStyle(_ref2) {\n  var width = _ref2.width;\n  return {\n    width: \"\".concat(width * 100, \"%\")\n  };\n};\nvar styles = {\n  progress: {\n    height: 2,\n    maxWidth: '100%',\n    background: '#555',\n    margin: 2,\n    borderRadius: 2,\n    WebkitBackfaceVisibility: 'hidden',\n    MozBackfaceVisibility: 'hidden',\n    msBackfaceVisibility: 'hidden',\n    backfaceVisibility: 'hidden'\n  }\n};\nexports[\"default\"] = ProgressWrapper;\n\n/***/ }),\n\n/***/ 771:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_27337__) {\n\n\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_27337__(639));\nvar Global_1 = __importDefault(__nested_webpack_require_27337__(267));\nfunction seeMore(props) {\n  var SeeMoreContent = props.seeMoreContent;\n  var CustomCollapsed = props.customCollapsed;\n  var _ref = (0, react_1.useContext)(Global_1[\"default\"]),\n    keyboardNavigation = _ref.keyboardNavigation;\n  (0, react_1.useEffect)(function () {\n    var isClient = typeof window !== 'undefined' && window.document;\n    if (isClient && typeof keyboardNavigation === 'boolean' && keyboardNavigation) {\n      document.addEventListener(\"keydown\", handleKeyDown);\n      return function () {\n        document.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }\n  }, [keyboardNavigation]);\n  var handleKeyDown = function handleKeyDown(e) {\n    if (e.key === 'ArrowUp') {\n      e.preventDefault();\n      props.toggleMore(true);\n    } else if (e.key === 'ArrowDown' || e.key === 'Escape') {\n      e.preventDefault();\n      props.toggleMore(false);\n    }\n  };\n  return props.showContent ? react_1[\"default\"].createElement(\"div\", {\n    style: styles.seeMoreExpanded\n  }, react_1[\"default\"].createElement(SeeMoreContent, {\n    close: function close() {\n      return props.toggleMore(false);\n    }\n  })) : CustomCollapsed ? react_1[\"default\"].createElement(CustomCollapsed, {\n    action: props.action,\n    toggleMore: props.toggleMore\n  }) : react_1[\"default\"].createElement(\"div\", {\n    style: styles.seeMore,\n    onClick: function onClick(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      props.toggleMore(true);\n    }\n  }, react_1[\"default\"].createElement(\"span\", {\n    style: styles.seeMoreIcon\n  }, \"\\u2303\"), react_1[\"default\"].createElement(\"span\", {\n    style: styles.seeMoreText\n  }, \"See more\"));\n}\nexports[\"default\"] = seeMore;\nvar styles = {\n  seeMore: {\n    height: \"10vh\",\n    background: \"linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.2))\",\n    display: \"flex\",\n    flexDirection: \"column\",\n    width: \"100%\",\n    alignItems: \"center\",\n    justifyContent: \"flex-end\",\n    bottom: 0\n  },\n  seeMoreExpanded: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    boxSizing: 'border-box',\n    zIndex: 99999\n  },\n  seeMoreText: {\n    color: \"white\",\n    textAlign: \"center\",\n    letterSpacing: \"0.1em\",\n    marginBottom: \"2.2vh\",\n    textTransform: \"capitalize\",\n    opacity: \"1\",\n    fontSize: \"0.8em\",\n    transition: \"opacity 300ms ease-in-out\"\n  },\n  seeMoreIcon: {\n    color: \"white\",\n    textAlign: \"center\",\n    letterSpacing: \"0.2em\",\n    marginBottom: \"0.4vh\",\n    opacity: \"1\",\n    filter: \"drop-shadow(0 0 5px black)\",\n    textTransform: \"capitalize\",\n    transition: \"opacity 300ms ease-in-out\"\n  },\n  seeMoreClose: {\n    position: \"absolute\",\n    filter: \"drop-shadow(0 3px 2px #ccc)\",\n    right: \"0.5rem\",\n    top: \"0.5rem\",\n    fontSize: \"1.5rem\",\n    opacity: \"0.7\",\n    padding: \"1rem\"\n  }\n};\n\n/***/ }),\n\n/***/ 353:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_31584__) {\n\n\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importDefault(__nested_webpack_require_31584__(639));\nvar puff_svg_1 = __importDefault(__nested_webpack_require_31584__(931));\nvar Spinner = function Spinner() {\n  return react_1[\"default\"].createElement(puff_svg_1[\"default\"], null);\n};\nexports[\"default\"] = Spinner;\n\n/***/ }),\n\n/***/ 832:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_32146__) {\n\n\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_32146__(639));\nvar Global_1 = __importDefault(__nested_webpack_require_32146__(267));\nvar Story = function Story(props) {\n  var globalContext = (0, react_1.useContext)(Global_1[\"default\"]);\n  var width = globalContext.width,\n    height = globalContext.height,\n    loader = globalContext.loader,\n    header = globalContext.header,\n    storyStyles = globalContext.storyStyles,\n    _globalContext$storyI = globalContext.storyInnerContainerStyles,\n    storyInnerContainerStyles = _globalContext$storyI === void 0 ? {} : _globalContext$storyI;\n  var rendererMessageHandler = function rendererMessageHandler(type, data) {\n    switch (type) {\n      case \"UPDATE_VIDEO_DURATION\":\n        props.getVideoDuration(data.duration);\n        return {\n          ack: \"OK\"\n        };\n    }\n  };\n  var getStoryContent = function getStoryContent() {\n    var InnerContent = props.story.content;\n    var config = {\n      width: width,\n      height: height,\n      loader: loader,\n      header: header,\n      storyStyles: storyStyles\n    };\n    return react_1[\"default\"].createElement(InnerContent, {\n      action: props.action,\n      isPaused: props.playState,\n      story: props.story,\n      config: config,\n      messageHandler: rendererMessageHandler\n    });\n  };\n  return react_1[\"default\"].createElement(\"div\", {\n    style: Object.assign(Object.assign(Object.assign({}, styles.story), storyInnerContainerStyles), {\n      width: width,\n      height: height\n    })\n  }, getStoryContent());\n};\nvar styles = {\n  story: {\n    display: \"flex\",\n    position: \"relative\",\n    overflow: \"hidden\",\n    alignItems: \"center\"\n  },\n  storyContent: {\n    width: \"auto\",\n    maxWidth: \"100%\",\n    maxHeight: \"100%\",\n    margin: \"auto\"\n  }\n};\nexports[\"default\"] = Story;\n\n/***/ }),\n\n/***/ 267:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_35247__) {\n\n\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.initialContext = void 0;\nvar react_1 = __importDefault(__nested_webpack_require_35247__(639));\nexports.initialContext = {\n  defaultInterval: 4000,\n  width: 360,\n  height: 640\n};\nvar GlobalContext = react_1[\"default\"].createContext(exports.initialContext);\nexports[\"default\"] = GlobalContext;\n\n/***/ }),\n\n/***/ 552:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_35839__) {\n\n\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importDefault(__nested_webpack_require_35839__(639));\nexports[\"default\"] = react_1[\"default\"].createContext({\n  currentId: 0,\n  videoDuration: 0,\n  bufferAction: false,\n  pause: false,\n  next: function next() {}\n});\n\n/***/ }),\n\n/***/ 486:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_36363__) {\n\n\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.initialContext = void 0;\nvar react_1 = __importDefault(__nested_webpack_require_36363__(639));\nexports.initialContext = {\n  stories: []\n};\nvar StoriesContext = react_1[\"default\"].createContext(exports.initialContext);\nexports[\"default\"] = StoriesContext;\n\n/***/ }),\n\n/***/ 370:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_36918__) {\n\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.WithSeeMore = exports.WithHeader = void 0;\nvar react_1 = __importStar(__nested_webpack_require_36918__(639));\nvar Container_1 = __importDefault(__nested_webpack_require_36918__(120));\nvar Global_1 = __importDefault(__nested_webpack_require_36918__(267));\nvar Stories_1 = __importDefault(__nested_webpack_require_36918__(486));\nvar renderers_1 = __nested_webpack_require_36918__(371);\nvar index_1 = __nested_webpack_require_36918__(942);\nvar withHeader_1 = __importDefault(__nested_webpack_require_36918__(803));\nvar withSeeMore_1 = __importDefault(__nested_webpack_require_36918__(763));\nvar ReactInstaStories = function ReactInstaStories(props) {\n  var renderers = props.renderers ? props.renderers.concat(index_1.renderers) : index_1.renderers;\n  var context = {\n    width: props.width,\n    height: props.height,\n    loader: props.loader,\n    header: props.header,\n    storyContainerStyles: props.storyContainerStyles,\n    storyInnerContainerStyles: props.storyInnerContainerStyles,\n    storyStyles: props.storyStyles,\n    progressContainerStyles: props.progressContainerStyles,\n    progressWrapperStyles: props.progressWrapperStyles,\n    progressStyles: props.progressStyles,\n    loop: props.loop,\n    defaultInterval: props.defaultInterval,\n    isPaused: props.isPaused,\n    currentIndex: props.currentIndex,\n    onStoryStart: props.onStoryStart,\n    onStoryEnd: props.onStoryEnd,\n    onAllStoriesEnd: props.onAllStoriesEnd,\n    onNext: props.onNext,\n    onPrevious: props.onPrevious,\n    keyboardNavigation: props.keyboardNavigation,\n    preventDefault: props.preventDefault,\n    preloadCount: props.preloadCount\n  };\n  var _ref = (0, react_1.useState)({\n      stories: generateStories(props.stories, renderers)\n    }),\n    _ref2 = _slicedToArray(_ref, 2),\n    stories = _ref2[0],\n    setStories = _ref2[1];\n  (0, react_1.useEffect)(function () {\n    setStories({\n      stories: generateStories(props.stories, renderers)\n    });\n  }, [props.stories, props.renderers]);\n  return react_1[\"default\"].createElement(Global_1[\"default\"].Provider, {\n    value: context\n  }, react_1[\"default\"].createElement(Stories_1[\"default\"].Provider, {\n    value: stories\n  }, react_1[\"default\"].createElement(Container_1[\"default\"], null)));\n};\nvar generateStories = function generateStories(stories, renderers) {\n  return stories.map(function (s) {\n    var story = {};\n    if (typeof s === 'string') {\n      story.url = s;\n      story.type = 'image';\n    } else if (_typeof(s) === 'object') {\n      story = Object.assign(story, s);\n    }\n    var renderer = (0, renderers_1.getRenderer)(story, renderers);\n    story.originalContent = story.content;\n    story.content = renderer;\n    return story;\n  });\n};\nReactInstaStories.defaultProps = {\n  width: 360,\n  height: 640,\n  defaultInterval: 4000,\n  preloadCount: 1\n};\nexports.WithHeader = withHeader_1[\"default\"];\nexports.WithSeeMore = withSeeMore_1[\"default\"];\nexports[\"default\"] = ReactInstaStories;\n\n/***/ }),\n\n/***/ 350:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_43048__) {\n\n\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.tester = exports.renderer = void 0;\nvar React = __importStar(__nested_webpack_require_43048__(639));\nvar renderer = function renderer(props) {\n  React.useEffect(function () {\n    props.action('play');\n  }, [props.story]);\n  var Content = props.story.originalContent;\n  return React.createElement(Content, Object.assign({}, props));\n};\nexports.renderer = renderer;\nvar tester = function tester(story) {\n  return {\n    condition: !!story.content,\n    priority: 2\n  };\n};\nexports.tester = tester;\nexports[\"default\"] = {\n  renderer: exports.renderer,\n  tester: exports.tester\n};\n\n/***/ }),\n\n/***/ 248:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_44817__) {\n\n\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.tester = exports.renderer = void 0;\nvar React = __importStar(__nested_webpack_require_44817__(639));\nvar renderer = function renderer(_ref) {\n  var story = _ref.story,\n    action = _ref.action;\n  React.useEffect(function () {\n    action(\"play\");\n  }, [story]);\n  return React.createElement(\"div\", {\n    style: styles.storyContent\n  }, React.createElement(\"p\", {\n    style: styles.text\n  }, \"This story could not be loaded.\"));\n};\nexports.renderer = renderer;\nvar styles = {\n  storyContent: {\n    width: \"100%\",\n    maxHeight: \"100%\",\n    margin: \"auto\"\n  },\n  text: {\n    textAlign: \"center\",\n    color: \"white\",\n    width: \"90%\",\n    margin: \"auto\"\n  }\n};\nvar tester = function tester() {\n  return {\n    condition: true,\n    priority: 1\n  };\n};\nexports.tester = tester;\nexports[\"default\"] = {\n  renderer: exports.renderer,\n  tester: exports.tester\n};\n\n/***/ }),\n\n/***/ 209:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_46863__) {\n\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.tester = exports.renderer = void 0;\nvar React = __importStar(__nested_webpack_require_46863__(639));\nvar Spinner_1 = __importDefault(__nested_webpack_require_46863__(353));\nvar withHeader_1 = __importDefault(__nested_webpack_require_46863__(803));\nvar withSeeMore_1 = __importDefault(__nested_webpack_require_46863__(763));\nvar renderer = function renderer(_ref) {\n  var story = _ref.story,\n    action = _ref.action,\n    isPaused = _ref.isPaused,\n    config = _ref.config;\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    loaded = _React$useState2[0],\n    setLoaded = _React$useState2[1];\n  var width = config.width,\n    height = config.height,\n    loader = config.loader,\n    storyStyles = config.storyStyles;\n  var computedStyles = Object.assign(Object.assign({}, styles.storyContent), storyStyles || {});\n  var imageLoaded = function imageLoaded() {\n    setLoaded(true);\n    action(\"play\");\n  };\n  return React.createElement(withHeader_1[\"default\"], Object.assign({}, {\n    story: story,\n    globalHeader: config.header\n  }), React.createElement(withSeeMore_1[\"default\"], Object.assign({}, {\n    story: story,\n    action: action\n  }), React.createElement(\"div\", null, React.createElement(\"img\", {\n    style: computedStyles,\n    src: story.url,\n    onLoad: imageLoaded\n  }), !loaded && React.createElement(\"div\", {\n    style: {\n      width: width,\n      height: height,\n      position: \"absolute\",\n      left: 0,\n      top: 0,\n      background: \"rgba(0, 0, 0, 0.9)\",\n      zIndex: 9,\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      color: \"#ccc\"\n    }\n  }, loader || React.createElement(Spinner_1[\"default\"], null)))));\n};\nexports.renderer = renderer;\nvar styles = {\n  story: {\n    display: \"flex\",\n    position: \"relative\",\n    overflow: \"hidden\"\n  },\n  storyContent: {\n    width: \"auto\",\n    maxWidth: \"100%\",\n    maxHeight: \"100%\",\n    margin: \"auto\"\n  }\n};\nvar tester = function tester(story) {\n  return {\n    condition: !story.content && (!story.type || story.type === \"image\"),\n    priority: 2\n  };\n};\nexports.tester = tester;\nexports[\"default\"] = {\n  renderer: exports.renderer,\n  tester: exports.tester\n};\n\n/***/ }),\n\n/***/ 544:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_51990__) {\n\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.tester = exports.renderer = void 0;\nvar React = __importStar(__nested_webpack_require_51990__(639));\nvar Spinner_1 = __importDefault(__nested_webpack_require_51990__(353));\nvar withHeader_1 = __importDefault(__nested_webpack_require_51990__(803));\nvar withSeeMore_1 = __importDefault(__nested_webpack_require_51990__(763));\nvar renderer = function renderer(_ref) {\n  var story = _ref.story,\n    action = _ref.action,\n    isPaused = _ref.isPaused,\n    config = _ref.config,\n    messageHandler = _ref.messageHandler;\n  var _React$useState = React.useState(false),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    loaded = _React$useState2[0],\n    setLoaded = _React$useState2[1];\n  var _React$useState3 = React.useState(false),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    muted = _React$useState4[0],\n    setMuted = _React$useState4[1];\n  var width = config.width,\n    height = config.height,\n    loader = config.loader,\n    storyStyles = config.storyStyles;\n  var computedStyles = Object.assign(Object.assign({}, styles.storyContent), storyStyles || {});\n  var vid = React.useRef(null);\n  React.useEffect(function () {\n    if (vid.current) {\n      if (isPaused) {\n        vid.current.pause();\n      } else {\n        vid.current.play()[\"catch\"](function () {});\n      }\n    }\n  }, [isPaused]);\n  var onWaiting = function onWaiting() {\n    action(\"pause\", true);\n  };\n  var onPlaying = function onPlaying() {\n    action(\"play\", true);\n  };\n  var videoLoaded = function videoLoaded() {\n    messageHandler(\"UPDATE_VIDEO_DURATION\", {\n      duration: vid.current.duration\n    });\n    setLoaded(true);\n    vid.current.play().then(function () {\n      action(\"play\");\n    })[\"catch\"](function () {\n      setMuted(true);\n      vid.current.play()[\"finally\"](function () {\n        action(\"play\");\n      });\n    });\n  };\n  return React.createElement(withHeader_1[\"default\"], Object.assign({}, {\n    story: story,\n    globalHeader: config.header\n  }), React.createElement(withSeeMore_1[\"default\"], Object.assign({}, {\n    story: story,\n    action: action\n  }), React.createElement(\"div\", {\n    style: styles.videoContainer\n  }, React.createElement(\"video\", {\n    ref: vid,\n    style: computedStyles,\n    src: story.url,\n    controls: false,\n    onLoadedData: videoLoaded,\n    playsInline: true,\n    onWaiting: onWaiting,\n    onPlaying: onPlaying,\n    muted: muted,\n    autoPlay: true,\n    \"webkit-playsinline\": \"true\"\n  }), !loaded && React.createElement(\"div\", {\n    style: {\n      width: width,\n      height: height,\n      position: \"absolute\",\n      left: 0,\n      top: 0,\n      background: \"rgba(0, 0, 0, 0.9)\",\n      zIndex: 9,\n      display: \"flex\",\n      justifyContent: \"center\",\n      alignItems: \"center\",\n      color: \"#ccc\"\n    }\n  }, loader || React.createElement(Spinner_1[\"default\"], null)))));\n};\nexports.renderer = renderer;\nvar styles = {\n  storyContent: {\n    width: \"auto\",\n    maxWidth: \"100%\",\n    maxHeight: \"100%\",\n    margin: \"auto\"\n  },\n  videoContainer: {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  }\n};\nvar tester = function tester(story) {\n  return {\n    condition: story.type === \"video\",\n    priority: 2\n  };\n};\nexports.tester = tester;\nexports[\"default\"] = {\n  renderer: exports.renderer,\n  tester: exports.tester\n};\n\n/***/ }),\n\n/***/ 942:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_58202__) {\n\n\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.renderers = void 0;\nvar Image_1 = __importDefault(__nested_webpack_require_58202__(209));\nvar Video_1 = __importDefault(__nested_webpack_require_58202__(544));\nvar Default_1 = __importDefault(__nested_webpack_require_58202__(248));\nvar AutoPlayContent_1 = __importDefault(__nested_webpack_require_58202__(350));\nexports.renderers = [Image_1[\"default\"], Video_1[\"default\"], AutoPlayContent_1[\"default\"], Default_1[\"default\"]];\n\n/***/ }),\n\n/***/ 803:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_58889__) {\n\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importDefault(__nested_webpack_require_58889__(639));\nvar Header_1 = __importDefault(__nested_webpack_require_58889__(463));\nvar withHeader = function withHeader(_ref) {\n  var story = _ref.story,\n    globalHeader = _ref.globalHeader,\n    children = _ref.children;\n  return react_1[\"default\"].createElement(react_1[\"default\"].Fragment, null, children, story.header && react_1[\"default\"].createElement(\"div\", {\n    style: {\n      position: \"absolute\",\n      left: 12,\n      top: 20,\n      zIndex: 19\n    }\n  }, _typeof(story) === \"object\" ? globalHeader ? globalHeader(story.header) : react_1[\"default\"].createElement(Header_1[\"default\"], {\n    heading: story.header.heading,\n    subheading: story.header.subheading,\n    profileImage: story.header.profileImage\n  }) : null));\n};\nexports[\"default\"] = withHeader;\n\n/***/ }),\n\n/***/ 763:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_60331__) {\n\n\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function get() {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __importStar(__nested_webpack_require_60331__(639));\nvar SeeMore_1 = __importDefault(__nested_webpack_require_60331__(771));\nvar withSeeMore = function withSeeMore(_ref) {\n  var story = _ref.story,\n    action = _ref.action,\n    customCollapsed = _ref.customCollapsed,\n    children = _ref.children;\n  var _ref2 = (0, react_1.useState)(false),\n    _ref3 = _slicedToArray(_ref2, 2),\n    showMore = _ref3[0],\n    setShowMore = _ref3[1];\n  var toggleMore = function toggleMore(show) {\n    action(show ? \"pause\" : \"play\");\n    setShowMore(show);\n  };\n  var CollapsedComponent = SeeMore_1[\"default\"];\n  return react_1[\"default\"].createElement(react_1[\"default\"].Fragment, null, children, story.seeMore && react_1[\"default\"].createElement(\"div\", {\n    style: {\n      position: \"absolute\",\n      margin: \"auto\",\n      bottom: showMore ? \"unset\" : 0,\n      zIndex: 9999,\n      width: \"100%\",\n      height: showMore ? \"100%\" : \"auto\"\n    }\n  }, react_1[\"default\"].createElement(CollapsedComponent, {\n    action: action,\n    toggleMore: toggleMore,\n    showContent: showMore,\n    seeMoreContent: story.seeMore,\n    customCollapsed: customCollapsed || story.seeMoreCollapsed\n  })));\n};\nexports[\"default\"] = withSeeMore;\n\n/***/ }),\n\n/***/ 371:\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getRenderer = void 0;\nvar getRenderer = function getRenderer(story, renderers) {\n  var probable = renderers.map(function (r) {\n    return Object.assign(Object.assign({}, r), {\n      testerResult: r.tester(story)\n    });\n  }).filter(function (r) {\n    return r.testerResult.condition;\n  });\n  probable.sort(function (a, b) {\n    return b.testerResult.priority - a.testerResult.priority;\n  });\n  return probable[0].renderer;\n};\nexports.getRenderer = getRenderer;\n\n/***/ }),\n\n/***/ 335:\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.timestamp = void 0;\nfunction timestamp() {\n  return window.performance && window.performance.now ? window.performance.now() : new Date().getTime();\n}\nexports.timestamp = timestamp;\n\n/***/ }),\n\n/***/ 342:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_65409__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nvar react_1 = __nested_webpack_require_65409__(639);\nfunction useIsMounted() {\n  var isMounted = (0, react_1.useRef)(false);\n  (0, react_1.useEffect)(function () {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n  return (0, react_1.useCallback)(function () {\n    return isMounted.current;\n  }, []);\n}\nexports[\"default\"] = useIsMounted;\n\n/***/ }),\n\n/***/ 402:\n/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_65959__) {\n\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.usePreLoader = void 0;\nvar react_1 = __nested_webpack_require_65959__(639);\n// Caches given Story[] using HTMLImageElement and HTMLVideoElement\nvar cacheContent = function cacheContent(contents) {\n  return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var promises;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          promises = contents.map(function (content) {\n            return new Promise(function (resolve, reject) {\n              if (!content.url) return;\n              if (content.type === 'video') {\n                var video = document.createElement('video');\n                video.src = content.url;\n                video.onloadeddata = resolve;\n                video.onerror = reject;\n                return;\n              }\n              var img = new Image();\n              img.src = content.url;\n              img.onload = resolve;\n              img.onerror = reject;\n            });\n          });\n          _context.next = 3;\n          return Promise.all(promises);\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n};\n// Keeps track of urls that have been loaded\nvar urlsLoaded = new Set();\n// Pushes urls to urlsLoaded\nvar markUrlsLoaded = function markUrlsLoaded(contents) {\n  contents.forEach(function (content) {\n    urlsLoaded.add(content.url);\n  });\n};\n// Returns true if given Story should be preloaded\nvar shouldPreload = function shouldPreload(content) {\n  if (!content.url) return false;\n  if (urlsLoaded.has(content.url)) return false;\n  if (content.preloadResource !== undefined) return content.preloadResource;\n  if (content.type === 'video') return false;\n  return true;\n};\n// Preloads images and videos from given Story[] using a cursor and preloadCount\n// Preload count is the number of images/videos to preload after the cursor\n// Cursor is the current index to start preloading from\nvar usePreLoader = function usePreLoader(contents, cursor, preloadCount) {\n  (0, react_1.useEffect)(function () {\n    var start = cursor + 1;\n    var end = cursor + preloadCount + 1;\n    var toPreload = contents.slice(start, end).filter(shouldPreload);\n    markUrlsLoaded(toPreload);\n    cacheContent(toPreload);\n  }, [cursor, preloadCount, contents]);\n};\nexports.usePreLoader = usePreLoader;\n\n/***/ }),\n\n/***/ 639:\n/***/ ((module) => {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__639__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_81981__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_81981__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_81981__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_81981__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_81981__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_81981__.o(definition, key) && !__nested_webpack_require_81981__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_81981__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_81981__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_81981__(370);\n/******/ \t\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtaW5zdGEtc3Rvcmllcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RCwyQkFBMkIsbUJBQU8sQ0FBQyx3R0FBTztBQUMxQyxNQUFNLEVBS3FDO0FBQzNDLENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQywwQkFBbUIsRUFBRSw4QkFBbUI7O0FBRXpFLDhCQUFtQixHQUFHLDBCQUFtQjtBQUN6QyxxQkFBcUIsOEJBQW1CLEdBQUcsMEJBQW1CO0FBQzlEO0FBQ0Esc0JBQXNCO0FBQ3RCLDhEQUE4RCw4QkFBbUI7QUFDakYsbUZBQW1GLDhCQUFtQjtBQUN0RztBQUNBLHNCQUFzQixzRUFBc0UsZ0JBQWdCLHNCQUFzQixPQUFPLDJCQUEyQiwwQkFBMEIseURBQXlELGlDQUFpQyxrQkFBa0I7QUFDMVMsc0RBQXNELCtCQUErQiw4REFBOEQsWUFBWSxvQ0FBb0MsNkRBQTZELFlBQVksNkJBQTZCLE9BQU8sMkJBQTJCLDBDQUEwQyx3RUFBd0UsK0JBQStCO0FBQzVkLDJEQUEyRCwrQkFBK0IsaUJBQWlCLHNDQUFzQyxZQUFZLFlBQVksdUJBQXVCLE9BQU8scUJBQXFCLDBDQUEwQyw2QkFBNkI7O0FBRW5TO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQsT0FBTzs7QUFFUDtBQUNBLGtEQUFrRCwrQkFBbUI7Ozs7QUFJckUsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QixrREFBa0QsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRDtBQUM3Uyx1Q0FBdUMsdURBQXVELHVDQUF1QyxTQUFTLHVCQUF1QjtBQUNySyx5Q0FBeUMseUdBQXlHLGtCQUFrQixpREFBaUQsTUFBTSw4Q0FBOEMsK0JBQStCLFdBQVcsWUFBWSw2RUFBNkUsWUFBWSxjQUFjLHFCQUFxQixVQUFVLE1BQU0sdUZBQXVGLFVBQVUsc0JBQXNCO0FBQ2xrQixnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMkJBQTJCLCtCQUFtQjtBQUM5QywrQkFBK0IsK0JBQW1CO0FBQ2xELGdDQUFnQywrQkFBbUI7QUFDbkQsaUNBQWlDLCtCQUFtQjtBQUNwRCw4QkFBOEIsK0JBQW1CO0FBQ2pELHNDQUFzQywrQkFBbUI7QUFDekQsdUNBQXVDLCtCQUFtQjtBQUMxRCxxQkFBcUIsK0JBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBLE9BQU87O0FBRVAsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGdDQUFtQjtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdDQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFtQixhQUFhLFdBQVc7QUFDdkQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLGdDQUFtQix3QkFBd0IsZ0NBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMEJBQW1CLEdBQUcsZ0NBQW1CO0FBQ3ZEO0FBQ0EsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJpZW5kYm9vay8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbnN0YS1zdG9yaWVzL2Rpc3QvaW5kZXguanM/MjA4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcIlN0b3JpZXNcIiwgW1wiUmVhY3RcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiU3Rvcmllc1wiXSA9IGZhY3RvcnkocmVxdWlyZShcInJlYWN0XCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJTdG9yaWVzXCJdID0gZmFjdG9yeShyb290W1wiUmVhY3RcIl0pO1xufSkodGhpcywgKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzYzOV9fKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHRcInVzZSBzdHJpY3RcIjtcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA5MzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiZGVmYXVsdFwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciByZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHJlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG52YXIgX2V4Y2x1ZGVkID0gW1wic3R5bGVzXCJdO1xuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkgeyBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTsgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpOyB2YXIga2V5LCBpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTsgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHsga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTsgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgX3JlZiRzdHlsZXMgPSBfcmVmLnN0eWxlcyxcbiAgICBzdHlsZXMgPSBfcmVmJHN0eWxlcyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJHN0eWxlcyxcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcmVmLCBfZXhjbHVkZWQpO1xuICByZXR1cm4gLyojX19QVVJFX18qL3JlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpLmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe1xuICAgIHdpZHRoOiBcIjQ0XCIsXG4gICAgaGVpZ2h0OiBcIjQ0XCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBzdHJva2U6IFwiI2ZmZlwiXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL3JlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpLmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMlwiXG4gIH0sIC8qI19fUFVSRV9fKi9yZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKS5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIsIHtcbiAgICBjeDogXCIyMlwiLFxuICAgIGN5OiBcIjIyXCIsXG4gICAgcjogXCIxXCJcbiAgfSwgLyojX19QVVJFX18qL3JlYWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpLmNyZWF0ZUVsZW1lbnQoXCJhbmltYXRlXCIsIHtcbiAgICBhdHRyaWJ1dGVOYW1lOiBcInJcIixcbiAgICBiZWdpbjogXCIwc1wiLFxuICAgIGR1cjogXCIxLjhzXCIsXG4gICAgdmFsdWVzOiBcIjE7IDIwXCIsXG4gICAgY2FsY01vZGU6IFwic3BsaW5lXCIsXG4gICAga2V5VGltZXM6IFwiMDsgMVwiLFxuICAgIGtleVNwbGluZXM6IFwiMC4xNjUsIDAuODQsIDAuNDQsIDFcIixcbiAgICByZXBlYXRDb3VudDogXCJpbmRlZmluaXRlXCJcbiAgfSksIC8qI19fUFVSRV9fKi9yZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKS5jcmVhdGVFbGVtZW50KFwiYW5pbWF0ZVwiLCB7XG4gICAgYXR0cmlidXRlTmFtZTogXCJzdHJva2Utb3BhY2l0eVwiLFxuICAgIGJlZ2luOiBcIjBzXCIsXG4gICAgZHVyOiBcIjEuOHNcIixcbiAgICB2YWx1ZXM6IFwiMTsgMFwiLFxuICAgIGNhbGNNb2RlOiBcInNwbGluZVwiLFxuICAgIGtleVRpbWVzOiBcIjA7IDFcIixcbiAgICBrZXlTcGxpbmVzOiBcIjAuMywgMC42MSwgMC4zNTUsIDFcIixcbiAgICByZXBlYXRDb3VudDogXCJpbmRlZmluaXRlXCJcbiAgfSkpLCAvKiNfX1BVUkVfXyovcmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7XG4gICAgY3g6IFwiMjJcIixcbiAgICBjeTogXCIyMlwiLFxuICAgIHI6IFwiMVwiXG4gIH0sIC8qI19fUFVSRV9fKi9yZWFjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKS5jcmVhdGVFbGVtZW50KFwiYW5pbWF0ZVwiLCB7XG4gICAgYXR0cmlidXRlTmFtZTogXCJyXCIsXG4gICAgYmVnaW46IFwiLTAuOXNcIixcbiAgICBkdXI6IFwiMS44c1wiLFxuICAgIHZhbHVlczogXCIxOyAyMFwiLFxuICAgIGNhbGNNb2RlOiBcInNwbGluZVwiLFxuICAgIGtleVRpbWVzOiBcIjA7IDFcIixcbiAgICBrZXlTcGxpbmVzOiBcIjAuMTY1LCAwLjg0LCAwLjQ0LCAxXCIsXG4gICAgcmVwZWF0Q291bnQ6IFwiaW5kZWZpbml0ZVwiXG4gIH0pLCAvKiNfX1BVUkVfXyovcmVhY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkuY3JlYXRlRWxlbWVudChcImFuaW1hdGVcIiwge1xuICAgIGF0dHJpYnV0ZU5hbWU6IFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgICBiZWdpbjogXCItMC45c1wiLFxuICAgIGR1cjogXCIxLjhzXCIsXG4gICAgdmFsdWVzOiBcIjE7IDBcIixcbiAgICBjYWxjTW9kZTogXCJzcGxpbmVcIixcbiAgICBrZXlUaW1lczogXCIwOyAxXCIsXG4gICAga2V5U3BsaW5lczogXCIwLjMsIDAuNjEsIDAuMzU1LCAxXCIsXG4gICAgcmVwZWF0Q291bnQ6IFwiaW5kZWZpbml0ZVwiXG4gIH0pKSkpO1xufSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMjA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSBfaSkgeyB2YXIgX3MsIF9lLCBfeCwgX3IsIF9hcnIgPSBbXSwgX24gPSAhMCwgX2QgPSAhMTsgdHJ5IHsgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7IGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuOyBfbiA9ICExOyB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7IH0gY2F0Y2ggKGVycikgeyBfZCA9ICEwLCBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBudWxsICE9IF9pW1wicmV0dXJuXCJdICYmIChfciA9IF9pW1wicmV0dXJuXCJdKCksIE9iamVjdChfcikgIT09IF9yKSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOSkpO1xudmFyIEdsb2JhbF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjY3KSk7XG52YXIgU3Rvcmllc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDg2KSk7XG52YXIgUHJvZ3Jlc3NfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MikpO1xudmFyIFN0b3J5XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4MzIpKTtcbnZhciBQcm9ncmVzc0FycmF5XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5MTMpKTtcbnZhciB1c2VfaXNfbW91bnRlZF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzQyKSk7XG52YXIgdXNlUHJlTG9hZGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwMik7XG5mdW5jdGlvbiBkZWZhdWx0XzEoKSB7XG4gIHZhciBfcmVmID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKDApLFxuICAgIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgY3VycmVudElkID0gX3JlZjJbMF0sXG4gICAgc2V0Q3VycmVudElkID0gX3JlZjJbMV07XG4gIHZhciBfcmVmMyA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh0cnVlKSxcbiAgICBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICBwYXVzZSA9IF9yZWY0WzBdLFxuICAgIHNldFBhdXNlID0gX3JlZjRbMV07XG4gIHZhciBfcmVmNSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSh0cnVlKSxcbiAgICBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCAyKSxcbiAgICBidWZmZXJBY3Rpb24gPSBfcmVmNlswXSxcbiAgICBzZXRCdWZmZXJBY3Rpb24gPSBfcmVmNlsxXTtcbiAgdmFyIF9yZWY3ID0gKDAsIHJlYWN0XzEudXNlU3RhdGUpKDApLFxuICAgIF9yZWY4ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjcsIDIpLFxuICAgIHZpZGVvRHVyYXRpb24gPSBfcmVmOFswXSxcbiAgICBzZXRWaWRlb0R1cmF0aW9uID0gX3JlZjhbMV07XG4gIHZhciBpc01vdW50ZWQgPSAoMCwgdXNlX2lzX21vdW50ZWRfMVtcImRlZmF1bHRcIl0pKCk7XG4gIHZhciBtb3VzZWRvd25JZCA9ICgwLCByZWFjdF8xLnVzZVJlZikoKTtcbiAgdmFyIF9yZWY5ID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoR2xvYmFsXzFbXCJkZWZhdWx0XCJdKSxcbiAgICB3aWR0aCA9IF9yZWY5LndpZHRoLFxuICAgIGhlaWdodCA9IF9yZWY5LmhlaWdodCxcbiAgICBsb29wID0gX3JlZjkubG9vcCxcbiAgICBjdXJyZW50SW5kZXggPSBfcmVmOS5jdXJyZW50SW5kZXgsXG4gICAgaXNQYXVzZWQgPSBfcmVmOS5pc1BhdXNlZCxcbiAgICBrZXlib2FyZE5hdmlnYXRpb24gPSBfcmVmOS5rZXlib2FyZE5hdmlnYXRpb24sXG4gICAgcHJldmVudERlZmF1bHQgPSBfcmVmOS5wcmV2ZW50RGVmYXVsdCxcbiAgICBfcmVmOSRzdG9yeUNvbnRhaW5lclMgPSBfcmVmOS5zdG9yeUNvbnRhaW5lclN0eWxlcyxcbiAgICBzdG9yeUNvbnRhaW5lclN0eWxlcyA9IF9yZWY5JHN0b3J5Q29udGFpbmVyUyA9PT0gdm9pZCAwID8ge30gOiBfcmVmOSRzdG9yeUNvbnRhaW5lclMsXG4gICAgb25BbGxTdG9yaWVzRW5kID0gX3JlZjkub25BbGxTdG9yaWVzRW5kLFxuICAgIG9uUHJldmlvdXMgPSBfcmVmOS5vblByZXZpb3VzLFxuICAgIG9uTmV4dCA9IF9yZWY5Lm9uTmV4dCxcbiAgICBwcmVsb2FkQ291bnQgPSBfcmVmOS5wcmVsb2FkQ291bnQ7XG4gIHZhciBfcmVmMTAgPSAoMCwgcmVhY3RfMS51c2VDb250ZXh0KShTdG9yaWVzXzFbXCJkZWZhdWx0XCJdKSxcbiAgICBzdG9yaWVzID0gX3JlZjEwLnN0b3JpZXM7XG4gICgwLCB1c2VQcmVMb2FkZXJfMS51c2VQcmVMb2FkZXIpKHN0b3JpZXMsIGN1cnJlbnRJZCwgcHJlbG9hZENvdW50KTtcbiAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBjdXJyZW50SW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPj0gMCAmJiBjdXJyZW50SW5kZXggPCBzdG9yaWVzLmxlbmd0aCkge1xuICAgICAgICBzZXRDdXJyZW50SWRXcmFwcGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEluZGV4O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbmRleCBvdXQgb2YgYm91bmRzLiBDdXJyZW50IGluZGV4IHdhcyBzZXQgdG8gdmFsdWUgbW9yZSB0aGFuIHRoZSBsZW5ndGggb2Ygc3RvcmllcyBhcnJheS5cIiwgY3VycmVudEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtjdXJyZW50SW5kZXhdKTtcbiAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBpc1BhdXNlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHNldFBhdXNlKGlzUGF1c2VkKTtcbiAgICB9XG4gIH0sIFtpc1BhdXNlZF0pO1xuICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXNDbGllbnQgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5kb2N1bWVudDtcbiAgICBpZiAoaXNDbGllbnQgJiYgdHlwZW9mIGtleWJvYXJkTmF2aWdhdGlvbiA9PT0gXCJib29sZWFuXCIgJiYga2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtrZXlib2FyZE5hdmlnYXRpb25dKTtcbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICBpZiAoZS5rZXkgPT09IFwiQXJyb3dMZWZ0XCIpIHtcbiAgICAgIHByZXZpb3VzKCk7XG4gICAgfSBlbHNlIGlmIChlLmtleSA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgIG5leHQoe1xuICAgICAgICBpc1NraXBwZWRCeVVzZXI6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgdmFyIHRvZ2dsZVN0YXRlID0gZnVuY3Rpb24gdG9nZ2xlU3RhdGUoYWN0aW9uLCBidWZmZXJBY3Rpb24pIHtcbiAgICBzZXRQYXVzZShhY3Rpb24gPT09IFwicGF1c2VcIik7XG4gICAgc2V0QnVmZmVyQWN0aW9uKCEhYnVmZmVyQWN0aW9uKTtcbiAgfTtcbiAgdmFyIHNldEN1cnJlbnRJZFdyYXBwZXIgPSBmdW5jdGlvbiBzZXRDdXJyZW50SWRXcmFwcGVyKGNhbGxiYWNrKSB7XG4gICAgc2V0Q3VycmVudElkKGNhbGxiYWNrKTtcbiAgICB0b2dnbGVTdGF0ZShcInBhdXNlXCIsIHRydWUpO1xuICB9O1xuICB2YXIgcHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICBpZiAob25QcmV2aW91cyAhPSB1bmRlZmluZWQpIHtcbiAgICAgIG9uUHJldmlvdXMoKTtcbiAgICB9XG4gICAgc2V0Q3VycmVudElkV3JhcHBlcihmdW5jdGlvbiAocHJldikge1xuICAgICAgcmV0dXJuIHByZXYgPiAwID8gcHJldiAtIDEgOiBwcmV2O1xuICAgIH0pO1xuICB9O1xuICB2YXIgbmV4dCA9IGZ1bmN0aW9uIG5leHQob3B0aW9ucykge1xuICAgIGlmIChvbk5leHQgIT0gdW5kZWZpbmVkICYmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaXNTa2lwcGVkQnlVc2VyKSkge1xuICAgICAgb25OZXh0KCk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGNvbXBvbmVudCBpcyBtb3VudGVkIC0gZm9yIGlzc3VlICMxMzAgKGh0dHBzOi8vZ2l0aHViLmNvbS9tb2hpdGswNS9yZWFjdC1pbnN0YS1zdG9yaWVzL2lzc3Vlcy8xMzApXG4gICAgaWYgKGlzTW91bnRlZCgpKSB7XG4gICAgICBpZiAobG9vcCkge1xuICAgICAgICB1cGRhdGVOZXh0U3RvcnlJZEZvckxvb3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZU5leHRTdG9yeUlkKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB2YXIgdXBkYXRlTmV4dFN0b3J5SWRGb3JMb29wID0gZnVuY3Rpb24gdXBkYXRlTmV4dFN0b3J5SWRGb3JMb29wKCkge1xuICAgIHNldEN1cnJlbnRJZFdyYXBwZXIoZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgIGlmIChwcmV2ID49IHN0b3JpZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICBvbkFsbFN0b3JpZXNFbmQgJiYgb25BbGxTdG9yaWVzRW5kKGN1cnJlbnRJZCwgc3Rvcmllcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHByZXYgKyAxKSAlIHN0b3JpZXMubGVuZ3RoO1xuICAgIH0pO1xuICB9O1xuICB2YXIgdXBkYXRlTmV4dFN0b3J5SWQgPSBmdW5jdGlvbiB1cGRhdGVOZXh0U3RvcnlJZCgpIHtcbiAgICBzZXRDdXJyZW50SWRXcmFwcGVyKGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICBpZiAocHJldiA8IHN0b3JpZXMubGVuZ3RoIC0gMSkgcmV0dXJuIHByZXYgKyAxO1xuICAgICAgb25BbGxTdG9yaWVzRW5kICYmIG9uQWxsU3Rvcmllc0VuZChjdXJyZW50SWQsIHN0b3JpZXMpO1xuICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSk7XG4gIH07XG4gIHZhciBkZWJvdW5jZVBhdXNlID0gZnVuY3Rpb24gZGVib3VuY2VQYXVzZShlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIG1vdXNlZG93bklkLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRvZ2dsZVN0YXRlKFwicGF1c2VcIik7XG4gICAgfSwgMjAwKTtcbiAgfTtcbiAgdmFyIG1vdXNlVXAgPSBmdW5jdGlvbiBtb3VzZVVwKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG1vdXNlZG93bklkLmN1cnJlbnQgJiYgY2xlYXJUaW1lb3V0KG1vdXNlZG93bklkLmN1cnJlbnQpO1xuICAgICAgaWYgKHBhdXNlKSB7XG4gICAgICAgIHRvZ2dsZVN0YXRlKFwicGxheVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGUgPT09IFwibmV4dFwiID8gbmV4dCh7XG4gICAgICAgICAgaXNTa2lwcGVkQnlVc2VyOiB0cnVlXG4gICAgICAgIH0pIDogcHJldmlvdXMoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICB2YXIgZ2V0VmlkZW9EdXJhdGlvbiA9IGZ1bmN0aW9uIGdldFZpZGVvRHVyYXRpb24oZHVyYXRpb24pIHtcbiAgICBzZXRWaWRlb0R1cmF0aW9uKGR1cmF0aW9uICogMTAwMCk7XG4gIH07XG4gIHJldHVybiByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlcy5jb250YWluZXIpLCBzdG9yeUNvbnRhaW5lclN0eWxlcyksIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSlcbiAgfSwgcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChQcm9ncmVzc18xW1wiZGVmYXVsdFwiXS5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBidWZmZXJBY3Rpb246IGJ1ZmZlckFjdGlvbixcbiAgICAgIHZpZGVvRHVyYXRpb246IHZpZGVvRHVyYXRpb24sXG4gICAgICBjdXJyZW50SWQ6IGN1cnJlbnRJZCxcbiAgICAgIHBhdXNlOiBwYXVzZSxcbiAgICAgIG5leHQ6IG5leHRcbiAgICB9XG4gIH0sIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoUHJvZ3Jlc3NBcnJheV8xW1wiZGVmYXVsdFwiXSwgbnVsbCkpLCByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFN0b3J5XzFbXCJkZWZhdWx0XCJdLCB7XG4gICAgYWN0aW9uOiB0b2dnbGVTdGF0ZSxcbiAgICBidWZmZXJBY3Rpb246IGJ1ZmZlckFjdGlvbixcbiAgICBwbGF5U3RhdGU6IHBhdXNlLFxuICAgIHN0b3J5OiBzdG9yaWVzW2N1cnJlbnRJZF0sXG4gICAgZ2V0VmlkZW9EdXJhdGlvbjogZ2V0VmlkZW9EdXJhdGlvblxuICB9KSwgIXByZXZlbnREZWZhdWx0ICYmIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZXMub3ZlcmxheVxuICB9LCByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IFwiNTAlXCIsXG4gICAgICB6SW5kZXg6IDk5OVxuICAgIH0sXG4gICAgb25Ub3VjaFN0YXJ0OiBkZWJvdW5jZVBhdXNlLFxuICAgIG9uVG91Y2hFbmQ6IG1vdXNlVXAoXCJwcmV2aW91c1wiKSxcbiAgICBvbk1vdXNlRG93bjogZGVib3VuY2VQYXVzZSxcbiAgICBvbk1vdXNlVXA6IG1vdXNlVXAoXCJwcmV2aW91c1wiKVxuICB9KSwgcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBcIjUwJVwiLFxuICAgICAgekluZGV4OiA5OTlcbiAgICB9LFxuICAgIG9uVG91Y2hTdGFydDogZGVib3VuY2VQYXVzZSxcbiAgICBvblRvdWNoRW5kOiBtb3VzZVVwKFwibmV4dFwiKSxcbiAgICBvbk1vdXNlRG93bjogZGVib3VuY2VQYXVzZSxcbiAgICBvbk1vdXNlVXA6IG1vdXNlVXAoXCJuZXh0XCIpXG4gIH0pKSk7XG59XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IGRlZmF1bHRfMTtcbnZhciBzdHlsZXMgPSB7XG4gIGNvbnRhaW5lcjoge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgYmFja2dyb3VuZDogXCIjMTExXCIsXG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICBXZWJraXRVc2VyU2VsZWN0OiAnbm9uZSdcbiAgfSxcbiAgb3ZlcmxheToge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgaGVpZ2h0OiBcImluaGVyaXRcIixcbiAgICB3aWR0aDogXCJpbmhlcml0XCIsXG4gICAgZGlzcGxheTogXCJmbGV4XCJcbiAgfVxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDQ2Mzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOSkpO1xudmFyIEhlYWRlciA9IGZ1bmN0aW9uIEhlYWRlcihfcmVmKSB7XG4gIHZhciBwcm9maWxlSW1hZ2UgPSBfcmVmLnByb2ZpbGVJbWFnZSxcbiAgICBoZWFkaW5nID0gX3JlZi5oZWFkaW5nLFxuICAgIHN1YmhlYWRpbmcgPSBfcmVmLnN1YmhlYWRpbmc7XG4gIHJldHVybiByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICBzdHlsZTogc3R5bGVzLm1haW5cbiAgfSwgcHJvZmlsZUltYWdlICYmIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwge1xuICAgIHN0eWxlOiBzdHlsZXMuaW1nLFxuICAgIHNyYzogcHJvZmlsZUltYWdlXG4gIH0pLCByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgc3R5bGU6IHN0eWxlcy50ZXh0XG4gIH0sIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICBzdHlsZTogc3R5bGVzLmhlYWRpbmdcbiAgfSwgaGVhZGluZyksIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJwXCIsIHtcbiAgICBzdHlsZTogc3R5bGVzLnN1YmhlYWRpbmdcbiAgfSwgc3ViaGVhZGluZykpKTtcbn07XG52YXIgc3R5bGVzID0ge1xuICBtYWluOiB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIlxuICB9LFxuICBpbWc6IHtcbiAgICB3aWR0aDogNDAsXG4gICAgaGVpZ2h0OiA0MCxcbiAgICBib3JkZXJSYWRpdXM6IDQwLFxuICAgIG1hcmdpblJpZ2h0OiAxMCxcbiAgICBmaWx0ZXI6IFwiZHJvcC1zaGFkb3coMCAwcHggMnB4IHJnYmEoMCwgMCwgMCwgMC41KSlcIixcbiAgICBib3JkZXI6IFwiMnB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC44KVwiXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGZpbHRlcjogXCJkcm9wLXNoYWRvdygwIDBweCAzcHggcmdiYSgwLCAwLCAwLCAwLjkpKVwiXG4gIH0sXG4gIGhlYWRpbmc6IHtcbiAgICBmb250U2l6ZTogXCIxcmVtXCIsXG4gICAgY29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpXCIsXG4gICAgbWFyZ2luOiAwLFxuICAgIG1hcmdpbkJvdHRvbTogMlxuICB9LFxuICBzdWJoZWFkaW5nOiB7XG4gICAgZm9udFNpemU6IFwiMC42cmVtXCIsXG4gICAgY29sb3I6IFwicmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpXCIsXG4gICAgbWFyZ2luOiAwXG4gIH1cbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IEhlYWRlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMTpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgIGRlc2MgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZcbiAgfSk7XG59IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciBQcm9ncmVzc1dyYXBwZXJfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQyNCkpO1xudmFyIEdsb2JhbF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjY3KSk7XG52YXIgUHJvZ3Jlc3NfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU1MikpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgdmFyIF9yZWYgPSAoMCwgcmVhY3RfMS51c2VDb250ZXh0KShHbG9iYWxfMVtcImRlZmF1bHRcIl0pLFxuICAgIHByb2dyZXNzU3R5bGVzID0gX3JlZi5wcm9ncmVzc1N0eWxlcztcbiAgdmFyIF9yZWYyID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoUHJvZ3Jlc3NfMVtcImRlZmF1bHRcIl0pLFxuICAgIGJ1ZmZlckFjdGlvbiA9IF9yZWYyLmJ1ZmZlckFjdGlvbixcbiAgICBwYXVzZSA9IF9yZWYyLnBhdXNlO1xuICB2YXIgZ2V0UHJvZ3Jlc3NTdHlsZSA9IGZ1bmN0aW9uIGdldFByb2dyZXNzU3R5bGUoX3JlZjMpIHtcbiAgICB2YXIgYWN0aXZlID0gX3JlZjMuYWN0aXZlO1xuICAgIHN3aXRjaCAoYWN0aXZlKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6ICcxMDAlJ1xuICAgICAgICB9O1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJzY2FsZVgoXCIuY29uY2F0KHByb3BzLmNvdW50IC8gMTAwLCBcIilcIilcbiAgICAgICAgfTtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgYWN0aXZlID0gcHJvcHMuYWN0aXZlO1xuICByZXR1cm4gcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChQcm9ncmVzc1dyYXBwZXJfMVtcImRlZmF1bHRcIl0sIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIGJ1ZmZlckFjdGlvbjogYnVmZmVyQWN0aW9uXG4gIH0sIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3R5bGVzLmlubmVyKSwgcHJvZ3Jlc3NTdHlsZXMpLCBnZXRQcm9ncmVzc1N0eWxlKHtcbiAgICAgIGFjdGl2ZTogYWN0aXZlXG4gICAgfSkpXG4gIH0pKTtcbn07XG52YXIgc3R5bGVzID0ge1xuICBpbm5lcjoge1xuICAgIGJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgIGJvcmRlclJhZGl1czogMixcbiAgICB0cmFuc2Zvcm1PcmlnaW46ICdjZW50ZXIgbGVmdCcsXG4gICAgV2Via2l0QmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICBNb3pCYWNrZmFjZVZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgIG1zQmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICBiYWNrZmFjZVZpc2liaWxpdHk6ICdoaWRkZW4nLFxuICAgIFdlYmtpdFBlcnNwZWN0aXZlOiAxMDAwLFxuICAgIE1velBlcnNwZWN0aXZlOiAxMDAwLFxuICAgIG1zUGVyc3BlY3RpdmU6IDEwMDAsXG4gICAgcGVyc3BlY3RpdmU6IDEwMDBcbiAgfVxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDkxMzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHsgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07IGlmIChudWxsICE9IF9pKSB7IHZhciBfcywgX2UsIF94LCBfciwgX2FyciA9IFtdLCBfbiA9ICEwLCBfZCA9ICExOyB0cnkgeyBpZiAoX3ggPSAoX2kgPSBfaS5jYWxsKGFycikpLm5leHQsIDAgPT09IGkpIHsgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47IF9uID0gITE7IH0gZWxzZSBmb3IgKDsgIShfbiA9IChfcyA9IF94LmNhbGwoX2kpKS5kb25lKSAmJiAoX2Fyci5wdXNoKF9zLnZhbHVlKSwgX2Fyci5sZW5ndGggIT09IGkpOyBfbiA9ICEwKTsgfSBjYXRjaCAoZXJyKSB7IF9kID0gITAsIF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIG51bGwgIT0gX2lbXCJyZXR1cm5cIl0gJiYgKF9yID0gX2lbXCJyZXR1cm5cIl0oKSwgT2JqZWN0KF9yKSAhPT0gX3IpKSByZXR1cm47IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSB9XG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciByZWFjdF8xID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNjM5KSk7XG52YXIgUHJvZ3Jlc3NfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkxMSkpO1xudmFyIFByb2dyZXNzXzIgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1NTIpKTtcbnZhciBHbG9iYWxfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NykpO1xudmFyIFN0b3JpZXNfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4NikpO1xudmFyIHRpbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzM1KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKSgwKSxcbiAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIGNvdW50ID0gX3JlZjJbMF0sXG4gICAgc2V0Q291bnQgPSBfcmVmMlsxXTtcbiAgdmFyIGxhc3RUaW1lID0gKDAsIHJlYWN0XzEudXNlUmVmKSgpO1xuICB2YXIgX3JlZjMgPSAoMCwgcmVhY3RfMS51c2VDb250ZXh0KShQcm9ncmVzc18yW1wiZGVmYXVsdFwiXSksXG4gICAgY3VycmVudElkID0gX3JlZjMuY3VycmVudElkLFxuICAgIG5leHQgPSBfcmVmMy5uZXh0LFxuICAgIHZpZGVvRHVyYXRpb24gPSBfcmVmMy52aWRlb0R1cmF0aW9uLFxuICAgIHBhdXNlID0gX3JlZjMucGF1c2UsXG4gICAgYnVmZmVyQWN0aW9uID0gX3JlZjMuYnVmZmVyQWN0aW9uO1xuICB2YXIgX3JlZjQgPSAoMCwgcmVhY3RfMS51c2VDb250ZXh0KShHbG9iYWxfMVtcImRlZmF1bHRcIl0pLFxuICAgIGRlZmF1bHRJbnRlcnZhbCA9IF9yZWY0LmRlZmF1bHRJbnRlcnZhbCxcbiAgICBvblN0b3J5RW5kID0gX3JlZjQub25TdG9yeUVuZCxcbiAgICBvblN0b3J5U3RhcnQgPSBfcmVmNC5vblN0b3J5U3RhcnQsXG4gICAgcHJvZ3Jlc3NDb250YWluZXJTdHlsZXMgPSBfcmVmNC5wcm9ncmVzc0NvbnRhaW5lclN0eWxlcztcbiAgdmFyIF9yZWY1ID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoU3Rvcmllc18xW1wiZGVmYXVsdFwiXSksXG4gICAgc3RvcmllcyA9IF9yZWY1LnN0b3JpZXM7XG4gICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIHNldENvdW50KDApO1xuICB9LCBbY3VycmVudElkLCBzdG9yaWVzXSk7XG4gICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGF1c2UpIHtcbiAgICAgIGFuaW1hdGlvbkZyYW1lSWQuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShpbmNyZW1lbnRDb3VudCk7XG4gICAgICBsYXN0VGltZS5jdXJyZW50ID0gKDAsIHRpbWVfMS50aW1lc3RhbXApKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkLmN1cnJlbnQpO1xuICAgIH07XG4gIH0sIFtjdXJyZW50SWQsIHBhdXNlXSk7XG4gIHZhciBhbmltYXRpb25GcmFtZUlkID0gKDAsIHJlYWN0XzEudXNlUmVmKSgpO1xuICB2YXIgY291bnRDb3B5ID0gY291bnQ7XG4gIHZhciBpbmNyZW1lbnRDb3VudCA9IGZ1bmN0aW9uIGluY3JlbWVudENvdW50KCkge1xuICAgIGlmIChjb3VudENvcHkgPT09IDApIHN0b3J5U3RhcnRDYWxsYmFjaygpO1xuICAgIGlmIChsYXN0VGltZS5jdXJyZW50ID09IHVuZGVmaW5lZCkgbGFzdFRpbWUuY3VycmVudCA9ICgwLCB0aW1lXzEudGltZXN0YW1wKSgpO1xuICAgIHZhciB0ID0gKDAsIHRpbWVfMS50aW1lc3RhbXApKCk7XG4gICAgdmFyIGR0ID0gdCAtIGxhc3RUaW1lLmN1cnJlbnQ7XG4gICAgbGFzdFRpbWUuY3VycmVudCA9IHQ7XG4gICAgc2V0Q291bnQoZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBnZXRDdXJyZW50SW50ZXJ2YWwoKTtcbiAgICAgIGNvdW50Q29weSA9IGNvdW50ICsgZHQgKiAxMDAgLyBpbnRlcnZhbDtcbiAgICAgIHJldHVybiBjb3VudENvcHk7XG4gICAgfSk7XG4gICAgaWYgKGNvdW50Q29weSA8IDEwMCkge1xuICAgICAgYW5pbWF0aW9uRnJhbWVJZC5jdXJyZW50ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGluY3JlbWVudENvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcnlFbmRDYWxsYmFjaygpO1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uRnJhbWVJZC5jdXJyZW50KTtcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gIH07XG4gIHZhciBzdG9yeVN0YXJ0Q2FsbGJhY2sgPSBmdW5jdGlvbiBzdG9yeVN0YXJ0Q2FsbGJhY2soKSB7XG4gICAgb25TdG9yeVN0YXJ0ICYmIG9uU3RvcnlTdGFydChjdXJyZW50SWQsIHN0b3JpZXNbY3VycmVudElkXSk7XG4gIH07XG4gIHZhciBzdG9yeUVuZENhbGxiYWNrID0gZnVuY3Rpb24gc3RvcnlFbmRDYWxsYmFjaygpIHtcbiAgICBvblN0b3J5RW5kICYmIG9uU3RvcnlFbmQoY3VycmVudElkLCBzdG9yaWVzW2N1cnJlbnRJZF0pO1xuICB9O1xuICB2YXIgZ2V0Q3VycmVudEludGVydmFsID0gZnVuY3Rpb24gZ2V0Q3VycmVudEludGVydmFsKCkge1xuICAgIGlmIChzdG9yaWVzW2N1cnJlbnRJZF0udHlwZSA9PT0gXCJ2aWRlb1wiKSByZXR1cm4gdmlkZW9EdXJhdGlvbjtcbiAgICBpZiAodHlwZW9mIHN0b3JpZXNbY3VycmVudElkXS5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHN0b3JpZXNbY3VycmVudElkXS5kdXJhdGlvbjtcbiAgICByZXR1cm4gZGVmYXVsdEludGVydmFsO1xuICB9O1xuICB2YXIgb3BhY2l0eVN0eWxlcyA9IHtcbiAgICBvcGFjaXR5OiBwYXVzZSAmJiAhYnVmZmVyQWN0aW9uID8gMCA6IDFcbiAgfTtcbiAgcmV0dXJuIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3R5bGVzLnByb2dyZXNzQXJyKSwgcHJvZ3Jlc3NDb250YWluZXJTdHlsZXMpLCBvcGFjaXR5U3R5bGVzKVxuICB9LCBzdG9yaWVzLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgIHJldHVybiByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFByb2dyZXNzXzFbXCJkZWZhdWx0XCJdLCB7XG4gICAgICBrZXk6IGksXG4gICAgICBjb3VudDogY291bnQsXG4gICAgICB3aWR0aDogMSAvIHN0b3JpZXMubGVuZ3RoLFxuICAgICAgYWN0aXZlOiBpID09PSBjdXJyZW50SWQgPyAxIDogaSA8IGN1cnJlbnRJZCA/IDIgOiAwXG4gICAgfSk7XG4gIH0pKTtcbn07XG52YXIgc3R5bGVzID0ge1xuICBwcm9ncmVzc0Fycjoge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICBmbGV4V3JhcDogXCJub3dyYXBcIixcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHdpZHRoOiBcIjk4JVwiLFxuICAgIHBhZGRpbmc6IDUsXG4gICAgcGFkZGluZ1RvcDogNyxcbiAgICBhbGlnblNlbGY6IFwiY2VudGVyXCIsXG4gICAgekluZGV4OiAxMDAxLFxuICAgIGZpbHRlcjogXCJkcm9wLXNoYWRvdygwIDFweCA4cHggIzIyMilcIixcbiAgICB0cmFuc2l0aW9uOiBcIm9wYWNpdHkgNDAwbXMgZWFzZS1pbi1vdXRcIlxuICB9XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDI0OlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG52YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOSkpO1xudmFyIEdsb2JhbF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjY3KSk7XG52YXIgUHJvZ3Jlc3NXcmFwcGVyID0gZnVuY3Rpb24gUHJvZ3Jlc3NXcmFwcGVyKHByb3BzKSB7XG4gIHZhciBfcmVmID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoR2xvYmFsXzFbXCJkZWZhdWx0XCJdKSxcbiAgICBwcm9ncmVzc1dyYXBwZXJTdHlsZXMgPSBfcmVmLnByb2dyZXNzV3JhcHBlclN0eWxlcztcbiAgcmV0dXJuIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3R5bGVzLnByb2dyZXNzKSwgcHJvZ3Jlc3NXcmFwcGVyU3R5bGVzKSwgZ2V0UHJvZ3Jlc3NXcmFwcGVyU3R5bGUocHJvcHMpKVxuICB9LCBwcm9wcy5jaGlsZHJlbik7XG59O1xudmFyIGdldFByb2dyZXNzV3JhcHBlclN0eWxlID0gZnVuY3Rpb24gZ2V0UHJvZ3Jlc3NXcmFwcGVyU3R5bGUoX3JlZjIpIHtcbiAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGg7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IFwiXCIuY29uY2F0KHdpZHRoICogMTAwLCBcIiVcIilcbiAgfTtcbn07XG52YXIgc3R5bGVzID0ge1xuICBwcm9ncmVzczoge1xuICAgIGhlaWdodDogMixcbiAgICBtYXhXaWR0aDogJzEwMCUnLFxuICAgIGJhY2tncm91bmQ6ICcjNTU1JyxcbiAgICBtYXJnaW46IDIsXG4gICAgYm9yZGVyUmFkaXVzOiAyLFxuICAgIFdlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgTW96QmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICBtc0JhY2tmYWNlVmlzaWJpbGl0eTogJ2hpZGRlbicsXG4gICAgYmFja2ZhY2VWaXNpYmlsaXR5OiAnaGlkZGVuJ1xuICB9XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBQcm9ncmVzc1dyYXBwZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NzE6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciByZWFjdF8xID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNjM5KSk7XG52YXIgR2xvYmFsXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNjcpKTtcbmZ1bmN0aW9uIHNlZU1vcmUocHJvcHMpIHtcbiAgdmFyIFNlZU1vcmVDb250ZW50ID0gcHJvcHMuc2VlTW9yZUNvbnRlbnQ7XG4gIHZhciBDdXN0b21Db2xsYXBzZWQgPSBwcm9wcy5jdXN0b21Db2xsYXBzZWQ7XG4gIHZhciBfcmVmID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoR2xvYmFsXzFbXCJkZWZhdWx0XCJdKSxcbiAgICBrZXlib2FyZE5hdmlnYXRpb24gPSBfcmVmLmtleWJvYXJkTmF2aWdhdGlvbjtcbiAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlzQ2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50O1xuICAgIGlmIChpc0NsaWVudCAmJiB0eXBlb2Yga2V5Ym9hcmROYXZpZ2F0aW9uID09PSAnYm9vbGVhbicgJiYga2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlEb3duKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleURvd24pO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtrZXlib2FyZE5hdmlnYXRpb25dKTtcbiAgdmFyIGhhbmRsZUtleURvd24gPSBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGUpIHtcbiAgICBpZiAoZS5rZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcHJvcHMudG9nZ2xlTW9yZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGUua2V5ID09PSAnQXJyb3dEb3duJyB8fCBlLmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHByb3BzLnRvZ2dsZU1vcmUoZmFsc2UpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHByb3BzLnNob3dDb250ZW50ID8gcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlcy5zZWVNb3JlRXhwYW5kZWRcbiAgfSwgcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChTZWVNb3JlQ29udGVudCwge1xuICAgIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy50b2dnbGVNb3JlKGZhbHNlKTtcbiAgICB9XG4gIH0pKSA6IEN1c3RvbUNvbGxhcHNlZCA/IHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ3VzdG9tQ29sbGFwc2VkLCB7XG4gICAgYWN0aW9uOiBwcm9wcy5hY3Rpb24sXG4gICAgdG9nZ2xlTW9yZTogcHJvcHMudG9nZ2xlTW9yZVxuICB9KSA6IHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiBzdHlsZXMuc2VlTW9yZSxcbiAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBwcm9wcy50b2dnbGVNb3JlKHRydWUpO1xuICAgIH1cbiAgfSwgcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICAgIHN0eWxlOiBzdHlsZXMuc2VlTW9yZUljb25cbiAgfSwgXCJcXHUyMzAzXCIpLCByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgc3R5bGU6IHN0eWxlcy5zZWVNb3JlVGV4dFxuICB9LCBcIlNlZSBtb3JlXCIpKTtcbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gc2VlTW9yZTtcbnZhciBzdHlsZXMgPSB7XG4gIHNlZU1vcmU6IHtcbiAgICBoZWlnaHQ6IFwiMTB2aFwiLFxuICAgIGJhY2tncm91bmQ6IFwibGluZWFyLWdyYWRpZW50KHJnYmEoMCwgMCwgMCwgMCksIHJnYmEoMCwgMCwgMCwgMC4yKSlcIixcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgIGp1c3RpZnlDb250ZW50OiBcImZsZXgtZW5kXCIsXG4gICAgYm90dG9tOiAwXG4gIH0sXG4gIHNlZU1vcmVFeHBhbmRlZDoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgekluZGV4OiA5OTk5OVxuICB9LFxuICBzZWVNb3JlVGV4dDoge1xuICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgdGV4dEFsaWduOiBcImNlbnRlclwiLFxuICAgIGxldHRlclNwYWNpbmc6IFwiMC4xZW1cIixcbiAgICBtYXJnaW5Cb3R0b206IFwiMi4ydmhcIixcbiAgICB0ZXh0VHJhbnNmb3JtOiBcImNhcGl0YWxpemVcIixcbiAgICBvcGFjaXR5OiBcIjFcIixcbiAgICBmb250U2l6ZTogXCIwLjhlbVwiLFxuICAgIHRyYW5zaXRpb246IFwib3BhY2l0eSAzMDBtcyBlYXNlLWluLW91dFwiXG4gIH0sXG4gIHNlZU1vcmVJY29uOiB7XG4gICAgY29sb3I6IFwid2hpdGVcIixcbiAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgbGV0dGVyU3BhY2luZzogXCIwLjJlbVwiLFxuICAgIG1hcmdpbkJvdHRvbTogXCIwLjR2aFwiLFxuICAgIG9wYWNpdHk6IFwiMVwiLFxuICAgIGZpbHRlcjogXCJkcm9wLXNoYWRvdygwIDAgNXB4IGJsYWNrKVwiLFxuICAgIHRleHRUcmFuc2Zvcm06IFwiY2FwaXRhbGl6ZVwiLFxuICAgIHRyYW5zaXRpb246IFwib3BhY2l0eSAzMDBtcyBlYXNlLWluLW91dFwiXG4gIH0sXG4gIHNlZU1vcmVDbG9zZToge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgZmlsdGVyOiBcImRyb3Atc2hhZG93KDAgM3B4IDJweCAjY2NjKVwiLFxuICAgIHJpZ2h0OiBcIjAuNXJlbVwiLFxuICAgIHRvcDogXCIwLjVyZW1cIixcbiAgICBmb250U2l6ZTogXCIxLjVyZW1cIixcbiAgICBvcGFjaXR5OiBcIjAuN1wiLFxuICAgIHBhZGRpbmc6IFwiMXJlbVwiXG4gIH1cbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNTM6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciBwdWZmX3N2Z18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOTMxKSk7XG52YXIgU3Bpbm5lciA9IGZ1bmN0aW9uIFNwaW5uZXIoKSB7XG4gIHJldHVybiByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KHB1ZmZfc3ZnXzFbXCJkZWZhdWx0XCJdLCBudWxsKTtcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IFNwaW5uZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MzI6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciByZWFjdF8xID0gX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNjM5KSk7XG52YXIgR2xvYmFsXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNjcpKTtcbnZhciBTdG9yeSA9IGZ1bmN0aW9uIFN0b3J5KHByb3BzKSB7XG4gIHZhciBnbG9iYWxDb250ZXh0ID0gKDAsIHJlYWN0XzEudXNlQ29udGV4dCkoR2xvYmFsXzFbXCJkZWZhdWx0XCJdKTtcbiAgdmFyIHdpZHRoID0gZ2xvYmFsQ29udGV4dC53aWR0aCxcbiAgICBoZWlnaHQgPSBnbG9iYWxDb250ZXh0LmhlaWdodCxcbiAgICBsb2FkZXIgPSBnbG9iYWxDb250ZXh0LmxvYWRlcixcbiAgICBoZWFkZXIgPSBnbG9iYWxDb250ZXh0LmhlYWRlcixcbiAgICBzdG9yeVN0eWxlcyA9IGdsb2JhbENvbnRleHQuc3RvcnlTdHlsZXMsXG4gICAgX2dsb2JhbENvbnRleHQkc3RvcnlJID0gZ2xvYmFsQ29udGV4dC5zdG9yeUlubmVyQ29udGFpbmVyU3R5bGVzLFxuICAgIHN0b3J5SW5uZXJDb250YWluZXJTdHlsZXMgPSBfZ2xvYmFsQ29udGV4dCRzdG9yeUkgPT09IHZvaWQgMCA/IHt9IDogX2dsb2JhbENvbnRleHQkc3RvcnlJO1xuICB2YXIgcmVuZGVyZXJNZXNzYWdlSGFuZGxlciA9IGZ1bmN0aW9uIHJlbmRlcmVyTWVzc2FnZUhhbmRsZXIodHlwZSwgZGF0YSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIlVQREFURV9WSURFT19EVVJBVElPTlwiOlxuICAgICAgICBwcm9wcy5nZXRWaWRlb0R1cmF0aW9uKGRhdGEuZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFjazogXCJPS1wiXG4gICAgICAgIH07XG4gICAgfVxuICB9O1xuICB2YXIgZ2V0U3RvcnlDb250ZW50ID0gZnVuY3Rpb24gZ2V0U3RvcnlDb250ZW50KCkge1xuICAgIHZhciBJbm5lckNvbnRlbnQgPSBwcm9wcy5zdG9yeS5jb250ZW50O1xuICAgIHZhciBjb25maWcgPSB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIGxvYWRlcjogbG9hZGVyLFxuICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICBzdG9yeVN0eWxlczogc3RvcnlTdHlsZXNcbiAgICB9O1xuICAgIHJldHVybiByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KElubmVyQ29udGVudCwge1xuICAgICAgYWN0aW9uOiBwcm9wcy5hY3Rpb24sXG4gICAgICBpc1BhdXNlZDogcHJvcHMucGxheVN0YXRlLFxuICAgICAgc3Rvcnk6IHByb3BzLnN0b3J5LFxuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBtZXNzYWdlSGFuZGxlcjogcmVuZGVyZXJNZXNzYWdlSGFuZGxlclxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHlsZXMuc3RvcnkpLCBzdG9yeUlubmVyQ29udGFpbmVyU3R5bGVzKSwge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9KVxuICB9LCBnZXRTdG9yeUNvbnRlbnQoKSk7XG59O1xudmFyIHN0eWxlcyA9IHtcbiAgc3Rvcnk6IHtcbiAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbiAgfSxcbiAgc3RvcnlDb250ZW50OiB7XG4gICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG1hcmdpbjogXCJhdXRvXCJcbiAgfVxufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3Rvcnk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNjc6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5pbml0aWFsQ29udGV4dCA9IHZvaWQgMDtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjM5KSk7XG5leHBvcnRzLmluaXRpYWxDb250ZXh0ID0ge1xuICBkZWZhdWx0SW50ZXJ2YWw6IDQwMDAsXG4gIHdpZHRoOiAzNjAsXG4gIGhlaWdodDogNjQwXG59O1xudmFyIEdsb2JhbENvbnRleHQgPSByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVDb250ZXh0KGV4cG9ydHMuaW5pdGlhbENvbnRleHQpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBHbG9iYWxDb250ZXh0O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNTUyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjM5KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUNvbnRleHQoe1xuICBjdXJyZW50SWQ6IDAsXG4gIHZpZGVvRHVyYXRpb246IDAsXG4gIGJ1ZmZlckFjdGlvbjogZmFsc2UsXG4gIHBhdXNlOiBmYWxzZSxcbiAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHt9XG59KTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDQ4Njpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmluaXRpYWxDb250ZXh0ID0gdm9pZCAwO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbmV4cG9ydHMuaW5pdGlhbENvbnRleHQgPSB7XG4gIHN0b3JpZXM6IFtdXG59O1xudmFyIFN0b3JpZXNDb250ZXh0ID0gcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlQ29udGV4dChleHBvcnRzLmluaXRpYWxDb250ZXh0KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gU3Rvcmllc0NvbnRleHQ7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9LCBfdHlwZW9mKG9iaik7IH1cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSBfaSkgeyB2YXIgX3MsIF9lLCBfeCwgX3IsIF9hcnIgPSBbXSwgX24gPSAhMCwgX2QgPSAhMTsgdHJ5IHsgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7IGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuOyBfbiA9ICExOyB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7IH0gY2F0Y2ggKGVycikgeyBfZCA9ICEwLCBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBudWxsICE9IF9pW1wicmV0dXJuXCJdICYmIChfciA9IF9pW1wicmV0dXJuXCJdKCksIE9iamVjdChfcikgIT09IF9yKSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLldpdGhTZWVNb3JlID0gZXhwb3J0cy5XaXRoSGVhZGVyID0gdm9pZCAwO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciBDb250YWluZXJfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCkpO1xudmFyIEdsb2JhbF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjY3KSk7XG52YXIgU3Rvcmllc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDg2KSk7XG52YXIgcmVuZGVyZXJzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MSk7XG52YXIgaW5kZXhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOTQyKTtcbnZhciB3aXRoSGVhZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4MDMpKTtcbnZhciB3aXRoU2VlTW9yZV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNzYzKSk7XG52YXIgUmVhY3RJbnN0YVN0b3JpZXMgPSBmdW5jdGlvbiBSZWFjdEluc3RhU3Rvcmllcyhwcm9wcykge1xuICB2YXIgcmVuZGVyZXJzID0gcHJvcHMucmVuZGVyZXJzID8gcHJvcHMucmVuZGVyZXJzLmNvbmNhdChpbmRleF8xLnJlbmRlcmVycykgOiBpbmRleF8xLnJlbmRlcmVycztcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgd2lkdGg6IHByb3BzLndpZHRoLFxuICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgIGxvYWRlcjogcHJvcHMubG9hZGVyLFxuICAgIGhlYWRlcjogcHJvcHMuaGVhZGVyLFxuICAgIHN0b3J5Q29udGFpbmVyU3R5bGVzOiBwcm9wcy5zdG9yeUNvbnRhaW5lclN0eWxlcyxcbiAgICBzdG9yeUlubmVyQ29udGFpbmVyU3R5bGVzOiBwcm9wcy5zdG9yeUlubmVyQ29udGFpbmVyU3R5bGVzLFxuICAgIHN0b3J5U3R5bGVzOiBwcm9wcy5zdG9yeVN0eWxlcyxcbiAgICBwcm9ncmVzc0NvbnRhaW5lclN0eWxlczogcHJvcHMucHJvZ3Jlc3NDb250YWluZXJTdHlsZXMsXG4gICAgcHJvZ3Jlc3NXcmFwcGVyU3R5bGVzOiBwcm9wcy5wcm9ncmVzc1dyYXBwZXJTdHlsZXMsXG4gICAgcHJvZ3Jlc3NTdHlsZXM6IHByb3BzLnByb2dyZXNzU3R5bGVzLFxuICAgIGxvb3A6IHByb3BzLmxvb3AsXG4gICAgZGVmYXVsdEludGVydmFsOiBwcm9wcy5kZWZhdWx0SW50ZXJ2YWwsXG4gICAgaXNQYXVzZWQ6IHByb3BzLmlzUGF1c2VkLFxuICAgIGN1cnJlbnRJbmRleDogcHJvcHMuY3VycmVudEluZGV4LFxuICAgIG9uU3RvcnlTdGFydDogcHJvcHMub25TdG9yeVN0YXJ0LFxuICAgIG9uU3RvcnlFbmQ6IHByb3BzLm9uU3RvcnlFbmQsXG4gICAgb25BbGxTdG9yaWVzRW5kOiBwcm9wcy5vbkFsbFN0b3JpZXNFbmQsXG4gICAgb25OZXh0OiBwcm9wcy5vbk5leHQsXG4gICAgb25QcmV2aW91czogcHJvcHMub25QcmV2aW91cyxcbiAgICBrZXlib2FyZE5hdmlnYXRpb246IHByb3BzLmtleWJvYXJkTmF2aWdhdGlvbixcbiAgICBwcmV2ZW50RGVmYXVsdDogcHJvcHMucHJldmVudERlZmF1bHQsXG4gICAgcHJlbG9hZENvdW50OiBwcm9wcy5wcmVsb2FkQ291bnRcbiAgfTtcbiAgdmFyIF9yZWYgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoe1xuICAgICAgc3RvcmllczogZ2VuZXJhdGVTdG9yaWVzKHByb3BzLnN0b3JpZXMsIHJlbmRlcmVycylcbiAgICB9KSxcbiAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgIHN0b3JpZXMgPSBfcmVmMlswXSxcbiAgICBzZXRTdG9yaWVzID0gX3JlZjJbMV07XG4gICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIHNldFN0b3JpZXMoe1xuICAgICAgc3RvcmllczogZ2VuZXJhdGVTdG9yaWVzKHByb3BzLnN0b3JpZXMsIHJlbmRlcmVycylcbiAgICB9KTtcbiAgfSwgW3Byb3BzLnN0b3JpZXMsIHByb3BzLnJlbmRlcmVyc10pO1xuICByZXR1cm4gcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChHbG9iYWxfMVtcImRlZmF1bHRcIl0uUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KFN0b3JpZXNfMVtcImRlZmF1bHRcIl0uUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3Rvcmllc1xuICB9LCByZWFjdF8xW1wiZGVmYXVsdFwiXS5jcmVhdGVFbGVtZW50KENvbnRhaW5lcl8xW1wiZGVmYXVsdFwiXSwgbnVsbCkpKTtcbn07XG52YXIgZ2VuZXJhdGVTdG9yaWVzID0gZnVuY3Rpb24gZ2VuZXJhdGVTdG9yaWVzKHN0b3JpZXMsIHJlbmRlcmVycykge1xuICByZXR1cm4gc3Rvcmllcy5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgc3RvcnkgPSB7fTtcbiAgICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzdG9yeS51cmwgPSBzO1xuICAgICAgc3RvcnkudHlwZSA9ICdpbWFnZSc7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgc3RvcnkgPSBPYmplY3QuYXNzaWduKHN0b3J5LCBzKTtcbiAgICB9XG4gICAgdmFyIHJlbmRlcmVyID0gKDAsIHJlbmRlcmVyc18xLmdldFJlbmRlcmVyKShzdG9yeSwgcmVuZGVyZXJzKTtcbiAgICBzdG9yeS5vcmlnaW5hbENvbnRlbnQgPSBzdG9yeS5jb250ZW50O1xuICAgIHN0b3J5LmNvbnRlbnQgPSByZW5kZXJlcjtcbiAgICByZXR1cm4gc3Rvcnk7XG4gIH0pO1xufTtcblJlYWN0SW5zdGFTdG9yaWVzLmRlZmF1bHRQcm9wcyA9IHtcbiAgd2lkdGg6IDM2MCxcbiAgaGVpZ2h0OiA2NDAsXG4gIGRlZmF1bHRJbnRlcnZhbDogNDAwMCxcbiAgcHJlbG9hZENvdW50OiAxXG59O1xuZXhwb3J0cy5XaXRoSGVhZGVyID0gd2l0aEhlYWRlcl8xW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHMuV2l0aFNlZU1vcmUgPSB3aXRoU2VlTW9yZV8xW1wiZGVmYXVsdFwiXTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmVhY3RJbnN0YVN0b3JpZXM7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNTA6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSB0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICBkZXNjID0ge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbVtrXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59IDogZnVuY3Rpb24gKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgdikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB2XG4gIH0pO1xufSA6IGZ1bmN0aW9uIChvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIgfHwgZnVuY3Rpb24gKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnRlc3RlciA9IGV4cG9ydHMucmVuZGVyZXIgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciByZW5kZXJlciA9IGZ1bmN0aW9uIHJlbmRlcmVyKHByb3BzKSB7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHMuYWN0aW9uKCdwbGF5Jyk7XG4gIH0sIFtwcm9wcy5zdG9yeV0pO1xuICB2YXIgQ29udGVudCA9IHByb3BzLnN0b3J5Lm9yaWdpbmFsQ29udGVudDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGVudCwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKTtcbn07XG5leHBvcnRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG52YXIgdGVzdGVyID0gZnVuY3Rpb24gdGVzdGVyKHN0b3J5KSB7XG4gIHJldHVybiB7XG4gICAgY29uZGl0aW9uOiAhIXN0b3J5LmNvbnRlbnQsXG4gICAgcHJpb3JpdHk6IDJcbiAgfTtcbn07XG5leHBvcnRzLnRlc3RlciA9IHRlc3RlcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0ge1xuICByZW5kZXJlcjogZXhwb3J0cy5yZW5kZXJlcixcbiAgdGVzdGVyOiBleHBvcnRzLnRlc3RlclxufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI0ODpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxudmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgIGRlc2MgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZcbiAgfSk7XG59IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMudGVzdGVyID0gZXhwb3J0cy5yZW5kZXJlciA9IHZvaWQgMDtcbnZhciBSZWFjdCA9IF9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOSkpO1xudmFyIHJlbmRlcmVyID0gZnVuY3Rpb24gcmVuZGVyZXIoX3JlZikge1xuICB2YXIgc3RvcnkgPSBfcmVmLnN0b3J5LFxuICAgIGFjdGlvbiA9IF9yZWYuYWN0aW9uO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGFjdGlvbihcInBsYXlcIik7XG4gIH0sIFtzdG9yeV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlcy5zdG9yeUNvbnRlbnRcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwge1xuICAgIHN0eWxlOiBzdHlsZXMudGV4dFxuICB9LCBcIlRoaXMgc3RvcnkgY291bGQgbm90IGJlIGxvYWRlZC5cIikpO1xufTtcbmV4cG9ydHMucmVuZGVyZXIgPSByZW5kZXJlcjtcbnZhciBzdHlsZXMgPSB7XG4gIHN0b3J5Q29udGVudDoge1xuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG1hcmdpbjogXCJhdXRvXCJcbiAgfSxcbiAgdGV4dDoge1xuICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICBjb2xvcjogXCJ3aGl0ZVwiLFxuICAgIHdpZHRoOiBcIjkwJVwiLFxuICAgIG1hcmdpbjogXCJhdXRvXCJcbiAgfVxufTtcbnZhciB0ZXN0ZXIgPSBmdW5jdGlvbiB0ZXN0ZXIoKSB7XG4gIHJldHVybiB7XG4gICAgY29uZGl0aW9uOiB0cnVlLFxuICAgIHByaW9yaXR5OiAxXG4gIH07XG59O1xuZXhwb3J0cy50ZXN0ZXIgPSB0ZXN0ZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgcmVuZGVyZXI6IGV4cG9ydHMucmVuZGVyZXIsXG4gIHRlc3RlcjogZXhwb3J0cy50ZXN0ZXJcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMDk6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSBfaSkgeyB2YXIgX3MsIF9lLCBfeCwgX3IsIF9hcnIgPSBbXSwgX24gPSAhMCwgX2QgPSAhMTsgdHJ5IHsgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7IGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuOyBfbiA9ICExOyB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7IH0gY2F0Y2ggKGVycikgeyBfZCA9ICEwLCBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBudWxsICE9IF9pW1wicmV0dXJuXCJdICYmIChfciA9IF9pW1wicmV0dXJuXCJdKCksIE9iamVjdChfcikgIT09IF9yKSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnRlc3RlciA9IGV4cG9ydHMucmVuZGVyZXIgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciBTcGlubmVyXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNTMpKTtcbnZhciB3aXRoSGVhZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4MDMpKTtcbnZhciB3aXRoU2VlTW9yZV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNzYzKSk7XG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbiByZW5kZXJlcihfcmVmKSB7XG4gIHZhciBzdG9yeSA9IF9yZWYuc3RvcnksXG4gICAgYWN0aW9uID0gX3JlZi5hY3Rpb24sXG4gICAgaXNQYXVzZWQgPSBfcmVmLmlzUGF1c2VkLFxuICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnO1xuICB2YXIgX1JlYWN0JHVzZVN0YXRlID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTIgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUsIDIpLFxuICAgIGxvYWRlZCA9IF9SZWFjdCR1c2VTdGF0ZTJbMF0sXG4gICAgc2V0TG9hZGVkID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcbiAgdmFyIHdpZHRoID0gY29uZmlnLndpZHRoLFxuICAgIGhlaWdodCA9IGNvbmZpZy5oZWlnaHQsXG4gICAgbG9hZGVyID0gY29uZmlnLmxvYWRlcixcbiAgICBzdG9yeVN0eWxlcyA9IGNvbmZpZy5zdG9yeVN0eWxlcztcbiAgdmFyIGNvbXB1dGVkU3R5bGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdHlsZXMuc3RvcnlDb250ZW50KSwgc3RvcnlTdHlsZXMgfHwge30pO1xuICB2YXIgaW1hZ2VMb2FkZWQgPSBmdW5jdGlvbiBpbWFnZUxvYWRlZCgpIHtcbiAgICBzZXRMb2FkZWQodHJ1ZSk7XG4gICAgYWN0aW9uKFwicGxheVwiKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQod2l0aEhlYWRlcl8xW1wiZGVmYXVsdFwiXSwgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgIHN0b3J5OiBzdG9yeSxcbiAgICBnbG9iYWxIZWFkZXI6IGNvbmZpZy5oZWFkZXJcbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQod2l0aFNlZU1vcmVfMVtcImRlZmF1bHRcIl0sIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICBzdG9yeTogc3RvcnksXG4gICAgYWN0aW9uOiBhY3Rpb25cbiAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgc3R5bGU6IGNvbXB1dGVkU3R5bGVzLFxuICAgIHNyYzogc3RvcnkudXJsLFxuICAgIG9uTG9hZDogaW1hZ2VMb2FkZWRcbiAgfSksICFsb2FkZWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBiYWNrZ3JvdW5kOiBcInJnYmEoMCwgMCwgMCwgMC45KVwiLFxuICAgICAgekluZGV4OiA5LFxuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9XG4gIH0sIGxvYWRlciB8fCBSZWFjdC5jcmVhdGVFbGVtZW50KFNwaW5uZXJfMVtcImRlZmF1bHRcIl0sIG51bGwpKSkpKTtcbn07XG5leHBvcnRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG52YXIgc3R5bGVzID0ge1xuICBzdG9yeToge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCJcbiAgfSxcbiAgc3RvcnlDb250ZW50OiB7XG4gICAgd2lkdGg6IFwiYXV0b1wiLFxuICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICBtYXhIZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG1hcmdpbjogXCJhdXRvXCJcbiAgfVxufTtcbnZhciB0ZXN0ZXIgPSBmdW5jdGlvbiB0ZXN0ZXIoc3RvcnkpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25kaXRpb246ICFzdG9yeS5jb250ZW50ICYmICghc3RvcnkudHlwZSB8fCBzdG9yeS50eXBlID09PSBcImltYWdlXCIpLFxuICAgIHByaW9yaXR5OiAyXG4gIH07XG59O1xuZXhwb3J0cy50ZXN0ZXIgPSB0ZXN0ZXI7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgcmVuZGVyZXI6IGV4cG9ydHMucmVuZGVyZXIsXG4gIHRlc3RlcjogZXhwb3J0cy50ZXN0ZXJcbn07XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NDQ6XG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdOyBpZiAobnVsbCAhPSBfaSkgeyB2YXIgX3MsIF9lLCBfeCwgX3IsIF9hcnIgPSBbXSwgX24gPSAhMCwgX2QgPSAhMTsgdHJ5IHsgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7IGlmIChPYmplY3QoX2kpICE9PSBfaSkgcmV0dXJuOyBfbiA9ICExOyB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7IH0gY2F0Y2ggKGVycikgeyBfZCA9ICEwLCBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBudWxsICE9IF9pW1wicmV0dXJuXCJdICYmIChfciA9IF9pW1wicmV0dXJuXCJdKCksIE9iamVjdChfcikgIT09IF9yKSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gfVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG52YXIgX19jcmVhdGVCaW5kaW5nID0gdGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgZGVzYyA9IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1ba107XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSA6IGZ1bmN0aW9uIChvLCBtLCBrLCBrMikge1xuICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICBvW2syXSA9IG1ba107XG59KTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24gKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogdlxuICB9KTtcbn0gOiBmdW5jdGlvbiAobywgdikge1xuICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSB0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnRlc3RlciA9IGV4cG9ydHMucmVuZGVyZXIgPSB2b2lkIDA7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciBTcGlubmVyXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNTMpKTtcbnZhciB3aXRoSGVhZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4MDMpKTtcbnZhciB3aXRoU2VlTW9yZV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNzYzKSk7XG52YXIgcmVuZGVyZXIgPSBmdW5jdGlvbiByZW5kZXJlcihfcmVmKSB7XG4gIHZhciBzdG9yeSA9IF9yZWYuc3RvcnksXG4gICAgYWN0aW9uID0gX3JlZi5hY3Rpb24sXG4gICAgaXNQYXVzZWQgPSBfcmVmLmlzUGF1c2VkLFxuICAgIGNvbmZpZyA9IF9yZWYuY29uZmlnLFxuICAgIG1lc3NhZ2VIYW5kbGVyID0gX3JlZi5tZXNzYWdlSGFuZGxlcjtcbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKSxcbiAgICBfUmVhY3QkdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX1JlYWN0JHVzZVN0YXRlLCAyKSxcbiAgICBsb2FkZWQgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgIHNldExvYWRlZCA9IF9SZWFjdCR1c2VTdGF0ZTJbMV07XG4gIHZhciBfUmVhY3QkdXNlU3RhdGUzID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpLFxuICAgIF9SZWFjdCR1c2VTdGF0ZTQgPSBfc2xpY2VkVG9BcnJheShfUmVhY3QkdXNlU3RhdGUzLCAyKSxcbiAgICBtdXRlZCA9IF9SZWFjdCR1c2VTdGF0ZTRbMF0sXG4gICAgc2V0TXV0ZWQgPSBfUmVhY3QkdXNlU3RhdGU0WzFdO1xuICB2YXIgd2lkdGggPSBjb25maWcud2lkdGgsXG4gICAgaGVpZ2h0ID0gY29uZmlnLmhlaWdodCxcbiAgICBsb2FkZXIgPSBjb25maWcubG9hZGVyLFxuICAgIHN0b3J5U3R5bGVzID0gY29uZmlnLnN0b3J5U3R5bGVzO1xuICB2YXIgY29tcHV0ZWRTdHlsZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlcy5zdG9yeUNvbnRlbnQpLCBzdG9yeVN0eWxlcyB8fCB7fSk7XG4gIHZhciB2aWQgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHZpZC5jdXJyZW50KSB7XG4gICAgICBpZiAoaXNQYXVzZWQpIHtcbiAgICAgICAgdmlkLmN1cnJlbnQucGF1c2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZC5jdXJyZW50LnBsYXkoKVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtpc1BhdXNlZF0pO1xuICB2YXIgb25XYWl0aW5nID0gZnVuY3Rpb24gb25XYWl0aW5nKCkge1xuICAgIGFjdGlvbihcInBhdXNlXCIsIHRydWUpO1xuICB9O1xuICB2YXIgb25QbGF5aW5nID0gZnVuY3Rpb24gb25QbGF5aW5nKCkge1xuICAgIGFjdGlvbihcInBsYXlcIiwgdHJ1ZSk7XG4gIH07XG4gIHZhciB2aWRlb0xvYWRlZCA9IGZ1bmN0aW9uIHZpZGVvTG9hZGVkKCkge1xuICAgIG1lc3NhZ2VIYW5kbGVyKFwiVVBEQVRFX1ZJREVPX0RVUkFUSU9OXCIsIHtcbiAgICAgIGR1cmF0aW9uOiB2aWQuY3VycmVudC5kdXJhdGlvblxuICAgIH0pO1xuICAgIHNldExvYWRlZCh0cnVlKTtcbiAgICB2aWQuY3VycmVudC5wbGF5KCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBhY3Rpb24oXCJwbGF5XCIpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge1xuICAgICAgc2V0TXV0ZWQodHJ1ZSk7XG4gICAgICB2aWQuY3VycmVudC5wbGF5KClbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0aW9uKFwicGxheVwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCh3aXRoSGVhZGVyXzFbXCJkZWZhdWx0XCJdLCBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgc3Rvcnk6IHN0b3J5LFxuICAgIGdsb2JhbEhlYWRlcjogY29uZmlnLmhlYWRlclxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudCh3aXRoU2VlTW9yZV8xW1wiZGVmYXVsdFwiXSwgT2JqZWN0LmFzc2lnbih7fSwge1xuICAgIHN0b3J5OiBzdG9yeSxcbiAgICBhY3Rpb246IGFjdGlvblxuICB9KSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHN0eWxlcy52aWRlb0NvbnRhaW5lclxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIiwge1xuICAgIHJlZjogdmlkLFxuICAgIHN0eWxlOiBjb21wdXRlZFN0eWxlcyxcbiAgICBzcmM6IHN0b3J5LnVybCxcbiAgICBjb250cm9sczogZmFsc2UsXG4gICAgb25Mb2FkZWREYXRhOiB2aWRlb0xvYWRlZCxcbiAgICBwbGF5c0lubGluZTogdHJ1ZSxcbiAgICBvbldhaXRpbmc6IG9uV2FpdGluZyxcbiAgICBvblBsYXlpbmc6IG9uUGxheWluZyxcbiAgICBtdXRlZDogbXV0ZWQsXG4gICAgYXV0b1BsYXk6IHRydWUsXG4gICAgXCJ3ZWJraXQtcGxheXNpbmxpbmVcIjogXCJ0cnVlXCJcbiAgfSksICFsb2FkZWQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBiYWNrZ3JvdW5kOiBcInJnYmEoMCwgMCwgMCwgMC45KVwiLFxuICAgICAgekluZGV4OiA5LFxuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAgICBjb2xvcjogXCIjY2NjXCJcbiAgICB9XG4gIH0sIGxvYWRlciB8fCBSZWFjdC5jcmVhdGVFbGVtZW50KFNwaW5uZXJfMVtcImRlZmF1bHRcIl0sIG51bGwpKSkpKTtcbn07XG5leHBvcnRzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG52YXIgc3R5bGVzID0ge1xuICBzdG9yeUNvbnRlbnQ6IHtcbiAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgbWF4V2lkdGg6IFwiMTAwJVwiLFxuICAgIG1heEhlaWdodDogXCIxMDAlXCIsXG4gICAgbWFyZ2luOiBcImF1dG9cIlxuICB9LFxuICB2aWRlb0NvbnRhaW5lcjoge1xuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCIsXG4gICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCJcbiAgfVxufTtcbnZhciB0ZXN0ZXIgPSBmdW5jdGlvbiB0ZXN0ZXIoc3RvcnkpIHtcbiAgcmV0dXJuIHtcbiAgICBjb25kaXRpb246IHN0b3J5LnR5cGUgPT09IFwidmlkZW9cIixcbiAgICBwcmlvcml0eTogMlxuICB9O1xufTtcbmV4cG9ydHMudGVzdGVyID0gdGVzdGVyO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB7XG4gIHJlbmRlcmVyOiBleHBvcnRzLnJlbmRlcmVyLFxuICB0ZXN0ZXI6IGV4cG9ydHMudGVzdGVyXG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTQyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7XG4gICAgXCJkZWZhdWx0XCI6IG1vZFxuICB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMucmVuZGVyZXJzID0gdm9pZCAwO1xudmFyIEltYWdlXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMDkpKTtcbnZhciBWaWRlb18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTQ0KSk7XG52YXIgRGVmYXVsdF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjQ4KSk7XG52YXIgQXV0b1BsYXlDb250ZW50XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNTApKTtcbmV4cG9ydHMucmVuZGVyZXJzID0gW0ltYWdlXzFbXCJkZWZhdWx0XCJdLCBWaWRlb18xW1wiZGVmYXVsdFwiXSwgQXV0b1BsYXlDb250ZW50XzFbXCJkZWZhdWx0XCJdLCBEZWZhdWx0XzFbXCJkZWZhdWx0XCJdXTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDgwMzpcbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH0sIF90eXBlb2Yob2JqKTsgfVxudmFyIF9faW1wb3J0RGVmYXVsdCA9IHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24gKG1vZCkge1xuICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDoge1xuICAgIFwiZGVmYXVsdFwiOiBtb2RcbiAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgcmVhY3RfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDYzOSkpO1xudmFyIEhlYWRlcl8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDYzKSk7XG52YXIgd2l0aEhlYWRlciA9IGZ1bmN0aW9uIHdpdGhIZWFkZXIoX3JlZikge1xuICB2YXIgc3RvcnkgPSBfcmVmLnN0b3J5LFxuICAgIGdsb2JhbEhlYWRlciA9IF9yZWYuZ2xvYmFsSGVhZGVyLFxuICAgIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbjtcbiAgcmV0dXJuIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQocmVhY3RfMVtcImRlZmF1bHRcIl0uRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCBzdG9yeS5oZWFkZXIgJiYgcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICBsZWZ0OiAxMixcbiAgICAgIHRvcDogMjAsXG4gICAgICB6SW5kZXg6IDE5XG4gICAgfVxuICB9LCBfdHlwZW9mKHN0b3J5KSA9PT0gXCJvYmplY3RcIiA/IGdsb2JhbEhlYWRlciA/IGdsb2JhbEhlYWRlcihzdG9yeS5oZWFkZXIpIDogcmVhY3RfMVtcImRlZmF1bHRcIl0uY3JlYXRlRWxlbWVudChIZWFkZXJfMVtcImRlZmF1bHRcIl0sIHtcbiAgICBoZWFkaW5nOiBzdG9yeS5oZWFkZXIuaGVhZGluZyxcbiAgICBzdWJoZWFkaW5nOiBzdG9yeS5oZWFkZXIuc3ViaGVhZGluZyxcbiAgICBwcm9maWxlSW1hZ2U6IHN0b3J5LmhlYWRlci5wcm9maWxlSW1hZ2VcbiAgfSkgOiBudWxsKSk7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB3aXRoSGVhZGVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNzYzOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTsgaWYgKG51bGwgIT0gX2kpIHsgdmFyIF9zLCBfZSwgX3gsIF9yLCBfYXJyID0gW10sIF9uID0gITAsIF9kID0gITE7IHRyeSB7IGlmIChfeCA9IChfaSA9IF9pLmNhbGwoYXJyKSkubmV4dCwgMCA9PT0gaSkgeyBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjsgX24gPSAhMTsgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApOyB9IGNhdGNoIChlcnIpIHsgX2QgPSAhMCwgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgbnVsbCAhPSBfaVtcInJldHVyblwiXSAmJiAoX3IgPSBfaVtcInJldHVyblwiXSgpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IH1cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxudmFyIF9fY3JlYXRlQmluZGluZyA9IHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcgfHwgKE9iamVjdC5jcmVhdGUgPyBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgIGRlc2MgPSB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtW2tdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0gOiBmdW5jdGlvbiAobywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gdGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCB8fCAoT2JqZWN0LmNyZWF0ZSA/IGZ1bmN0aW9uIChvLCB2KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgdmFsdWU6IHZcbiAgfSk7XG59IDogZnVuY3Rpb24gKG8sIHYpIHtcbiAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gdGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhciB8fCBmdW5jdGlvbiAobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSB0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgcmV0dXJuIG1vZCAmJiBtb2QuX19lc01vZHVsZSA/IG1vZCA6IHtcbiAgICBcImRlZmF1bHRcIjogbW9kXG4gIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xudmFyIHJlYWN0XzEgPSBfX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpKTtcbnZhciBTZWVNb3JlXzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3NzEpKTtcbnZhciB3aXRoU2VlTW9yZSA9IGZ1bmN0aW9uIHdpdGhTZWVNb3JlKF9yZWYpIHtcbiAgdmFyIHN0b3J5ID0gX3JlZi5zdG9yeSxcbiAgICBhY3Rpb24gPSBfcmVmLmFjdGlvbixcbiAgICBjdXN0b21Db2xsYXBzZWQgPSBfcmVmLmN1c3RvbUNvbGxhcHNlZCxcbiAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBfcmVmMiA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShmYWxzZSksXG4gICAgX3JlZjMgPSBfc2xpY2VkVG9BcnJheShfcmVmMiwgMiksXG4gICAgc2hvd01vcmUgPSBfcmVmM1swXSxcbiAgICBzZXRTaG93TW9yZSA9IF9yZWYzWzFdO1xuICB2YXIgdG9nZ2xlTW9yZSA9IGZ1bmN0aW9uIHRvZ2dsZU1vcmUoc2hvdykge1xuICAgIGFjdGlvbihzaG93ID8gXCJwYXVzZVwiIDogXCJwbGF5XCIpO1xuICAgIHNldFNob3dNb3JlKHNob3cpO1xuICB9O1xuICB2YXIgQ29sbGFwc2VkQ29tcG9uZW50ID0gU2VlTW9yZV8xW1wiZGVmYXVsdFwiXTtcbiAgcmV0dXJuIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQocmVhY3RfMVtcImRlZmF1bHRcIl0uRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuLCBzdG9yeS5zZWVNb3JlICYmIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgbWFyZ2luOiBcImF1dG9cIixcbiAgICAgIGJvdHRvbTogc2hvd01vcmUgPyBcInVuc2V0XCIgOiAwLFxuICAgICAgekluZGV4OiA5OTk5LFxuICAgICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgICAgaGVpZ2h0OiBzaG93TW9yZSA/IFwiMTAwJVwiIDogXCJhdXRvXCJcbiAgICB9XG4gIH0sIHJlYWN0XzFbXCJkZWZhdWx0XCJdLmNyZWF0ZUVsZW1lbnQoQ29sbGFwc2VkQ29tcG9uZW50LCB7XG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgdG9nZ2xlTW9yZTogdG9nZ2xlTW9yZSxcbiAgICBzaG93Q29udGVudDogc2hvd01vcmUsXG4gICAgc2VlTW9yZUNvbnRlbnQ6IHN0b3J5LnNlZU1vcmUsXG4gICAgY3VzdG9tQ29sbGFwc2VkOiBjdXN0b21Db2xsYXBzZWQgfHwgc3Rvcnkuc2VlTW9yZUNvbGxhcHNlZFxuICB9KSkpO1xufTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gd2l0aFNlZU1vcmU7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNzE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmdldFJlbmRlcmVyID0gdm9pZCAwO1xudmFyIGdldFJlbmRlcmVyID0gZnVuY3Rpb24gZ2V0UmVuZGVyZXIoc3RvcnksIHJlbmRlcmVycykge1xuICB2YXIgcHJvYmFibGUgPSByZW5kZXJlcnMubWFwKGZ1bmN0aW9uIChyKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgciksIHtcbiAgICAgIHRlc3RlclJlc3VsdDogci50ZXN0ZXIoc3RvcnkpXG4gICAgfSk7XG4gIH0pLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgIHJldHVybiByLnRlc3RlclJlc3VsdC5jb25kaXRpb247XG4gIH0pO1xuICBwcm9iYWJsZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIudGVzdGVyUmVzdWx0LnByaW9yaXR5IC0gYS50ZXN0ZXJSZXN1bHQucHJpb3JpdHk7XG4gIH0pO1xuICByZXR1cm4gcHJvYmFibGVbMF0ucmVuZGVyZXI7XG59O1xuZXhwb3J0cy5nZXRSZW5kZXJlciA9IGdldFJlbmRlcmVyO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMzM1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy50aW1lc3RhbXAgPSB2b2lkIDA7XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHJldHVybiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xufVxuZXhwb3J0cy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG52YXIgcmVhY3RfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjM5KTtcbmZ1bmN0aW9uIHVzZUlzTW91bnRlZCgpIHtcbiAgdmFyIGlzTW91bnRlZCA9ICgwLCByZWFjdF8xLnVzZVJlZikoZmFsc2UpO1xuICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgfTtcbiAgfSwgW10pO1xuICByZXR1cm4gKDAsIHJlYWN0XzEudXNlQ2FsbGJhY2spKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNNb3VudGVkLmN1cnJlbnQ7XG4gIH0sIFtdKTtcbn1cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdXNlSXNNb3VudGVkO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNDAyOlxuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfSwgX3R5cGVvZihvYmopOyB9XG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyBcInVzZSBzdHJpY3RcIjsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxudmFyIF9fYXdhaXRlciA9IHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7XG4gICAgICByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTtcbiAgICB9XG4gICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLnVzZVByZUxvYWRlciA9IHZvaWQgMDtcbnZhciByZWFjdF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzkpO1xuLy8gQ2FjaGVzIGdpdmVuIFN0b3J5W10gdXNpbmcgSFRNTEltYWdlRWxlbWVudCBhbmQgSFRNTFZpZGVvRWxlbWVudFxudmFyIGNhY2hlQ29udGVudCA9IGZ1bmN0aW9uIGNhY2hlQ29udGVudChjb250ZW50cykge1xuICByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciBwcm9taXNlcztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBwcm9taXNlcyA9IGNvbnRlbnRzLm1hcChmdW5jdGlvbiAoY29udGVudCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCFjb250ZW50LnVybCkgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgICAgICAgICB2aWRlby5zcmMgPSBjb250ZW50LnVybDtcbiAgICAgICAgICAgICAgICB2aWRlby5vbmxvYWRlZGRhdGEgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHZpZGVvLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgaW1nLnNyYyA9IGNvbnRlbnQudXJsO1xuICAgICAgICAgICAgICBpbWcub25sb2FkID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG59O1xuLy8gS2VlcHMgdHJhY2sgb2YgdXJscyB0aGF0IGhhdmUgYmVlbiBsb2FkZWRcbnZhciB1cmxzTG9hZGVkID0gbmV3IFNldCgpO1xuLy8gUHVzaGVzIHVybHMgdG8gdXJsc0xvYWRlZFxudmFyIG1hcmtVcmxzTG9hZGVkID0gZnVuY3Rpb24gbWFya1VybHNMb2FkZWQoY29udGVudHMpIHtcbiAgY29udGVudHMuZm9yRWFjaChmdW5jdGlvbiAoY29udGVudCkge1xuICAgIHVybHNMb2FkZWQuYWRkKGNvbnRlbnQudXJsKTtcbiAgfSk7XG59O1xuLy8gUmV0dXJucyB0cnVlIGlmIGdpdmVuIFN0b3J5IHNob3VsZCBiZSBwcmVsb2FkZWRcbnZhciBzaG91bGRQcmVsb2FkID0gZnVuY3Rpb24gc2hvdWxkUHJlbG9hZChjb250ZW50KSB7XG4gIGlmICghY29udGVudC51cmwpIHJldHVybiBmYWxzZTtcbiAgaWYgKHVybHNMb2FkZWQuaGFzKGNvbnRlbnQudXJsKSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoY29udGVudC5wcmVsb2FkUmVzb3VyY2UgIT09IHVuZGVmaW5lZCkgcmV0dXJuIGNvbnRlbnQucHJlbG9hZFJlc291cmNlO1xuICBpZiAoY29udGVudC50eXBlID09PSAndmlkZW8nKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufTtcbi8vIFByZWxvYWRzIGltYWdlcyBhbmQgdmlkZW9zIGZyb20gZ2l2ZW4gU3RvcnlbXSB1c2luZyBhIGN1cnNvciBhbmQgcHJlbG9hZENvdW50XG4vLyBQcmVsb2FkIGNvdW50IGlzIHRoZSBudW1iZXIgb2YgaW1hZ2VzL3ZpZGVvcyB0byBwcmVsb2FkIGFmdGVyIHRoZSBjdXJzb3Jcbi8vIEN1cnNvciBpcyB0aGUgY3VycmVudCBpbmRleCB0byBzdGFydCBwcmVsb2FkaW5nIGZyb21cbnZhciB1c2VQcmVMb2FkZXIgPSBmdW5jdGlvbiB1c2VQcmVMb2FkZXIoY29udGVudHMsIGN1cnNvciwgcHJlbG9hZENvdW50KSB7XG4gICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFydCA9IGN1cnNvciArIDE7XG4gICAgdmFyIGVuZCA9IGN1cnNvciArIHByZWxvYWRDb3VudCArIDE7XG4gICAgdmFyIHRvUHJlbG9hZCA9IGNvbnRlbnRzLnNsaWNlKHN0YXJ0LCBlbmQpLmZpbHRlcihzaG91bGRQcmVsb2FkKTtcbiAgICBtYXJrVXJsc0xvYWRlZCh0b1ByZWxvYWQpO1xuICAgIGNhY2hlQ29udGVudCh0b1ByZWxvYWQpO1xuICB9LCBbY3Vyc29yLCBwcmVsb2FkQ291bnQsIGNvbnRlbnRzXSk7XG59O1xuZXhwb3J0cy51c2VQcmVMb2FkZXIgPSB1c2VQcmVMb2FkZXI7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2Mzk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzYzOV9fO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyBcdH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0XHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG4vKioqKioqLyBcdFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHRcdH1cbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gc3RhcnR1cFxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0Ly8gVGhpcyBlbnRyeSBtb2R1bGUgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBtb2R1bGVzIHNvIGl0IGNhbid0IGJlIGlubGluZWRcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19leHBvcnRzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3MCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-insta-stories/dist/index.js\n");

/***/ })

};
;